// Generated by dts-bundle-generator v9.5.1

import * as https from 'https';
import is from 'is';
import * as jsonc from 'jsonc-parser';
import * as vm from 'vm';
import * as vscode from 'vscode';

declare interface Buffer$1 extends ArrayBuffer {
}
declare enum RelationshipType {
	None = 0,
	OfficeDocument = 1,
	Worksheet = 2,
	CalcChain = 3,
	SharedStrings = 4,
	Styles = 5,
	Theme = 6,
	Hyperlink = 7
}
declare enum DocumentType {
	Xlsx = 1
}
declare const enum PaperSize {
	Legal = 5,
	Executive = 7,
	A4 = 9,
	A5 = 11,
	B5 = 13,
	Envelope_10 = 20,
	Envelope_DL = 27,
	Envelope_C5 = 28,
	Envelope_B5 = 34,
	Envelope_Monarch = 37,
	Double_Japan_Postcard_Rotated = 82,
	K16_197x273_mm = 119
}
interface WorksheetViewCommon {
	/**
	 * Sets the worksheet view's orientation to right-to-left, `false` by default
	 */
	rightToLeft: boolean;
	/**
	 * The currently selected cell
	 */
	activeCell: string;
	/**
	 * Shows or hides the ruler in Page Layout, `true` by default
	 */
	showRuler: boolean;
	/**
	 * Shows or hides the row and column headers (e.g. A1, B1 at the top and 1,2,3 on the left,
	 * `true` by default
	 */
	showRowColHeaders: boolean;
	/**
	 * Shows or hides the gridlines (shown for cells where borders have not been defined),
	 * `true` by default
	 */
	showGridLines: boolean;
	/**
	 * 	Percentage zoom to use for the view, `100` by default
	 */
	zoomScale: number;
	/**
	 * 	Normal zoom for the view, `100` by default
	 */
	zoomScaleNormal: number;
}
interface WorksheetViewNormal {
	/**
	 * Controls the view state
	 */
	state: "normal";
	/**
	 * Presentation style
	 */
	style: "pageBreakPreview" | "pageLayout";
}
interface WorksheetViewFrozen {
	/**
	 * Where a number of rows and columns to the top and left are frozen in place.
	 * Only the bottom left section will scroll
	 */
	state: "frozen";
	/**
	 * Presentation style
	 */
	style?: "pageBreakPreview";
	/**
	 * How many columns to freeze. To freeze rows only, set this to 0 or undefined
	 */
	xSplit?: number;
	/**
	 * How many rows to freeze. To freeze columns only, set this to 0 or undefined
	 */
	ySplit?: number;
	/**
	 * Which cell will be top-left in the bottom-right pane. Note: cannot be a frozen cell.
	 * Defaults to first unfrozen cell
	 */
	topLeftCell?: string;
}
interface WorksheetViewSplit {
	/**
	 * Where the view is split into 4 sections, each semi-independently scrollable.
	 */
	state: "split";
	/**
	 * Presentation style
	 */
	style?: "pageBreakPreview" | "pageLayout";
	/**
	 * How many points from the left to place the splitter.
	 * To split vertically, set this to 0 or undefined
	 */
	xSplit?: number;
	/**
	 * How many points from the top to place the splitter.
	 * To split horizontally, set this to 0 or undefined
	 */
	ySplit?: number;
	/**
	 * Which cell will be top-left in the bottom-right pane
	 */
	topLeftCell?: string;
	/**
	 * Which pane will be active
	 */
	activePane?: "topLeft" | "topRight" | "bottomLeft" | "bottomRight";
}
type WorksheetView = WorksheetViewCommon & (WorksheetViewNormal | WorksheetViewFrozen | WorksheetViewSplit);
interface WorkbookView {
	x: number;
	y: number;
	width: number;
	height: number;
	firstSheet: number;
	activeTab: number;
	visibility: string;
}
type FillPatterns = "none" | "solid" | "darkVertical" | "darkHorizontal" | "darkGrid" | "darkTrellis" | "darkDown" | "darkUp" | "lightVertical" | "lightHorizontal" | "lightGrid" | "lightTrellis" | "lightDown" | "lightUp" | "darkGray" | "mediumGray" | "lightGray" | "gray125" | "gray0625";
interface FillPattern {
	type: "pattern";
	pattern: FillPatterns;
	fgColor?: Partial<Color>;
	bgColor?: Partial<Color>;
}
interface GradientStop {
	position: number;
	color: Partial<Color>;
}
interface FillGradientAngle {
	type: "gradient";
	gradient: "angle";
	/**
	 * For 'angle' gradient, specifies the direction of the gradient. 0 is from the left to the right.
	 * Values from 1 - 359 rotates the direction clockwise
	 */
	degree: number;
	/**
	 * Specifies the gradient colour sequence. Is an array of objects containing position and
	 * color starting with position 0 and ending with position 1.
	 * Intermediary positions may be used to specify other colours on the path.
	 */
	stops: GradientStop[];
}
interface FillGradientPath {
	type: "gradient";
	gradient: "path";
	/**
	 * For 'path' gradient. Specifies the relative coordinates for the start of the path.
	 * 'left' and 'top' values range from 0 to 1
	 */
	center: {
		left: number;
		top: number;
	};
	/**
	 * Specifies the gradient colour sequence. Is an array of objects containing position and
	 * color starting with position 0 and ending with position 1.
	 * Intermediary positions may be used to specify other colours on the path.
	 */
	stops: GradientStop[];
}
type Fill = FillPattern | FillGradientAngle | FillGradientPath;
interface Font {
	name: string;
	size: number;
	family: number;
	scheme: "minor" | "major" | "none";
	charset: number;
	color: Partial<Color>;
	bold: boolean;
	italic: boolean;
	underline: boolean | "none" | "single" | "double" | "singleAccounting" | "doubleAccounting";
	vertAlign: "superscript" | "subscript";
	strike: boolean;
	outline: boolean;
}
type BorderStyle = "thin" | "dotted" | "hair" | "medium" | "double" | "thick" | "dashed" | "dashDot" | "dashDotDot" | "slantDashDot" | "mediumDashed" | "mediumDashDotDot" | "mediumDashDot";
interface Color {
	/**
	 * Hex string for alpha-red-green-blue e.g. FF00FF00
	 */
	argb: string;
	/**
	 * Choose a theme by index
	 */
	theme: number;
}
interface Border {
	style: BorderStyle;
	color: Partial<Color>;
}
interface BorderDiagonal extends Border {
	up: boolean;
	down: boolean;
}
interface Borders {
	top: Partial<Border>;
	left: Partial<Border>;
	bottom: Partial<Border>;
	right: Partial<Border>;
	diagonal: Partial<BorderDiagonal>;
}
interface Margins {
	top: number;
	left: number;
	bottom: number;
	right: number;
	header: number;
	footer: number;
}
declare enum ReadingOrder {
	LeftToRight = 1,
	RightToLeft = 2
}
interface Alignment {
	horizontal: "left" | "center" | "right" | "fill" | "justify" | "centerContinuous" | "distributed";
	vertical: "top" | "middle" | "bottom" | "distributed" | "justify";
	wrapText: boolean;
	shrinkToFit: boolean;
	indent: number;
	readingOrder: "rtl" | "ltr";
	textRotation: number | "vertical";
}
interface Protection {
	locked: boolean;
	hidden: boolean;
}
interface Style {
	numFmt: string;
	font: Partial<Font>;
	alignment: Partial<Alignment>;
	protection: Partial<Protection>;
	border: Partial<Borders>;
	fill: Fill;
}
type DataValidationOperator = "between" | "notBetween" | "equal" | "notEqual" | "greaterThan" | "lessThan" | "greaterThanOrEqual" | "lessThanOrEqual";
interface DataValidation {
	type: "list" | "whole" | "decimal" | "date" | "textLength" | "custom";
	formulae: any[];
	allowBlank?: boolean;
	operator?: DataValidationOperator;
	error?: string;
	errorTitle?: string;
	errorStyle?: string;
	prompt?: string;
	promptTitle?: string;
	showErrorMessage?: boolean;
	showInputMessage?: boolean;
}
declare enum ErrorValue {
	NotApplicable = "#N/A",
	Ref = "#REF!",
	Name = "#NAME?",
	DivZero = "#DIV/0!",
	Null = "#NULL!",
	Value = "#VALUE!",
	Num = "#NUM!"
}
interface CellErrorValue {
	error: "#N/A" | "#REF!" | "#NAME?" | "#DIV/0!" | "#NULL!" | "#VALUE!" | "#NUM!";
}
interface RichText {
	text: string;
	font?: Partial<Font>;
}
interface CellRichTextValue {
	richText: RichText[];
}
interface CellHyperlinkValue {
	text: string;
	hyperlink: string;
	tooltip?: string;
}
interface CellFormulaValue {
	formula: string;
	result?: number | string | boolean | Date | CellErrorValue;
	date1904?: boolean;
}
interface CellSharedFormulaValue {
	sharedFormula: string;
	readonly formula?: string;
	result?: number | string | boolean | Date | CellErrorValue;
	date1904?: boolean;
}
declare enum ValueType {
	Null = 0,
	Merge = 1,
	Number = 2,
	String = 3,
	Date = 4,
	Hyperlink = 5,
	Formula = 6,
	SharedString = 7,
	RichText = 8,
	Boolean = 9,
	Error = 10
}
declare enum FormulaType {
	None = 0,
	Master = 1,
	Shared = 2
}
type CellValue = null | number | string | boolean | Date | undefined | CellErrorValue | CellRichTextValue | CellHyperlinkValue | CellFormulaValue | CellSharedFormulaValue;
interface CommentMargins {
	insetmode: "auto" | "custom";
	inset: Number[];
}
interface CommentProtection {
	locked: "True" | "False";
	lockText: "True" | "False";
}
type CommentEditAs = "twoCells" | "oneCells" | "absolute";
interface Comment {
	texts?: RichText[];
	margins?: Partial<CommentMargins>;
	protection?: Partial<CommentProtection>;
	editAs?: CommentEditAs;
}
interface CellModel {
	address: Address;
	style: Style;
	type: ValueType;
	text?: string;
	hyperlink?: string;
	value?: CellValue;
	master: string;
	formula?: string;
	sharedFormula?: string;
	result?: string | number | any;
	comment: Comment;
}
interface Cell extends Style, Address {
	readonly worksheet: Worksheet;
	readonly workbook: Workbook;
	readonly effectiveType: ValueType;
	readonly isMerged: boolean;
	readonly master: Cell;
	readonly isHyperlink: boolean;
	readonly hyperlink: string; // todo
	readonly text: string;
	readonly fullAddress: {
		sheetName: string;
		address: string;
		row: number;
		col: number;
	};
	model: CellModel;
	/**
	 * Assign (or get) a name for a cell (will overwrite any other names that cell had)
	 */
	name: string;
	/**
	 * Assign (or get) an array of names for a cell (cells can have more than one name)
	 */
	names: string[];
	/**
	 * Cells can define what values are valid or not and provide
	 * prompting to the user to help guide them.
	 */
	dataValidation: DataValidation;
	/**
	 * Value of the cell
	 */
	value: CellValue;
	/**
	 * comment of the cell
	 */
	note: string | Comment;
	/**
	 * convenience getter to access the formula
	 */
	readonly formula: string;
	/**
	 * convenience getter to access the formula result
	 */
	readonly result: number | string | Date;
	/**
	 * The type of the cell's value
	 */
	readonly type: ValueType;
	/**
	 * The type of the cell's formula
	 */
	readonly formulaType: FormulaType;
	/**
	 * The styles of the cell
	 */
	style: Partial<Style>;
	addName(name: string): void;
	/**
	 * Remove a name from a cell
	 */
	removeName(name: string): void;
	removeAllNames(): void;
	destroy(): void;
	toCsvString(): string;
	release(): void;
	addMergeRef(): void;
	releaseMergeRef(): void;
	merge(master: Cell, ignoreStyle?: boolean): void;
	unmerge(): void;
	isMergedTo(master: Cell): boolean;
	toString(): string;
}
interface RowModel {
	cells: CellModel[];
	number: number;
	min: number;
	max: number;
	height: number;
	style: Partial<Style>;
	hidden: boolean;
	outlineLevel: number;
	collapsed: boolean;
}
interface Row extends Style {
	readonly worksheet: Worksheet;
	readonly hasValues: boolean;
	readonly dimensions: number;
	model: Partial<RowModel> | null;
	/**
	 * Set a specific row height
	 */
	height: number;
	/**
	 * Make row hidden
	 */
	hidden: boolean;
	/**
	 * Get a row as a sparse array
	 */
	// readonly values: CellValue[];
	values: CellValue[] | {
		[key: string]: CellValue;
	};
	/**
	 * Set an outline level for rows
	 */
	outlineLevel?: number;
	/**
	 * The row number
	 */
	readonly number: number;
	/**
	 * Indicate the collapsed state based on outlineLevel
	 */
	readonly collapsed: boolean;
	/**
	 * Number of cells including empty ones
	 */
	readonly cellCount: number;
	/**
	 * Number of non-empty cells
	 */
	readonly actualCellCount: number;
	/**
	 * Get cell by number, column letter or column key
	 */
	getCell(indexOrKey: number | string): Cell;
	findCell(colNumber: number): Cell | undefined;
	getCellEx(address: Address): Cell;
	/**
	 * Iterate over all non-null cells in a row
	 */
	eachCell(callback: (cell: Cell, colNumber: number) => void): void;
	/**
	 * Iterate over all cells in a row (including empty cells)
	 */
	eachCell(opt: {
		includeEmpty: boolean;
	}, callback: (cell: Cell, colNumber: number) => void): void;
	/**
	 * Cut one or more cells (cells to the right are shifted left)
	 *
	 * Note: this operation will not affect other rows
	 */
	splice(start: number, count: number, ...insert: any[]): void;
	/**
	 * Commit a completed row to stream
	 */
	commit(): void;
	destroy(): void;
	addPageBreak(lft?: number, rght?: number): void;
}
interface Column {
	/**
	 * Can be a string to set one row high header or an array to set multi-row high header
	 */
	header?: string | string[];
	/**
	 * The name of the properties associated with this column in each row
	 */
	key?: string;
	/**
	 * The width of the column
	 */
	width?: number;
	/**
	 * Set an outline level for columns
	 */
	outlineLevel: number;
	/**
	 * Hides the column
	 */
	hidden: boolean;
	/**
	 * Styles applied to the column
	 */
	style: Partial<Style>;
	/**
	 * The cell values in the column
	 */
	values: ReadonlyArray<CellValue>;
	/**
	 * Column letter key
	 */
	readonly letter: string;
	readonly number: number;
	readonly worksheet: Worksheet;
	readonly isCustomWidth: boolean;
	readonly headers: string[];
	readonly isDefault: boolean;
	readonly headerCount: number;
	/**
	 * Below properties read from style
	 */
	border?: Partial<Borders>;
	fill?: Fill;
	numFmt?: string;
	font?: Partial<Font>;
	alignment?: Partial<Alignment>;
	protection?: Partial<Protection>;
	toString(): string;
	equivalentTo(other: Column): boolean;
	/**
	 * indicate the collapsed state based on outlineLevel
	 */
	readonly collapsed: boolean;
	/**
	 * Iterate over all current cells in this column
	 */
	eachCell(callback: (cell: Cell, rowNumber: number) => void): void;
	/**
	 * Iterate over all current cells in this column including empty cells
	 */
	eachCell(opt: {
		includeEmpty: boolean;
	}, callback: (cell: Cell, rowNumber: number) => void): void;
	defn: any; //todo
}
interface PageSetup {
	/**
	 * Whitespace on the borders of the page. Units are inches.
	 */
	margins: Margins;
	/**
	 * Orientation of the page - i.e. taller (`'portrait'`) or wider (`'landscape'`).
	 *
	 * `'portrait'` by default
	 */
	orientation: "portrait" | "landscape";
	/**
	 * Horizontal Dots per Inch. Default value is 4294967295
	 */
	horizontalDpi: number;
	/**
	 * Vertical Dots per Inch. Default value is 4294967295
	 */
	verticalDpi: number;
	/**
	 * Whether to use fitToWidth and fitToHeight or scale settings.
	 *
	 * Default is based on presence of these settings in the pageSetup object - if both are present,
	 * scale wins (i.e. default will be false)
	 */
	fitToPage: boolean;
	/**
	 * How many pages wide the sheet should print on to. Active when fitToPage is true
	 *
	 * Default is 1
	 */
	fitToWidth: number;
	/**
	 * How many pages high the sheet should print on to. Active when fitToPage is true
	 *
	 * Default is 1
	 */
	fitToHeight: number;
	/**
	 * Percentage value to increase or reduce the size of the print. Active when fitToPage is false
	 *
	 * Default is 100
	 */
	scale: number;
	/**
	 * Which order to print the pages.
	 *
	 * Default is `downThenOver`
	 */
	pageOrder: "downThenOver" | "overThenDown";
	/**
	 * Print without colour
	 *
	 * false by default
	 */
	blackAndWhite: boolean;
	/**
	 * Print with less quality (and ink)
	 *
	 * false by default
	 */
	draft: boolean;
	/**
	 * Where to place comments
	 *
	 * Default is `None`
	 */
	cellComments: "atEnd" | "asDisplayed" | "None";
	/**
	 * Where to show errors
	 *
	 * Default is `displayed`
	 */
	errors: "dash" | "blank" | "NA" | "displayed";
	/**
	 * 	What paper size to use (see below)
	 *
	 * | Name                          | Value       |
	 * | ----------------------------- | ---------   |
	 * | Letter                        | `undefined` |
	 * | Legal                         |  `5`        |
	 * | Executive                     |  `7`        |
	 * | A4                            |  `9`        |
	 * | A5                            |  `11`       |
	 * | B5 (JIS)                      |  `13`       |
	 * | Envelope #10                  |  `20`       |
	 * | Envelope DL                   |  `27`       |
	 * | Envelope C5                   |  `28`       |
	 * | Envelope B5                   |  `34`       |
	 * | Envelope Monarch              |  `37`       |
	 * | Double Japan Postcard Rotated |  `82`       |
	 * | 16K 197x273 mm                |  `119`      |
	 */
	paperSize: PaperSize;
	/**
	 * Whether to show the row numbers and column letters, `false` by default
	 */
	showRowColHeaders: boolean;
	/**
	 * Whether to show grid lines, `false` by default
	 */
	showGridLines: boolean;
	/**
	 * Which number to use for the first page
	 */
	firstPageNumber: number;
	/**
	 * 	Whether to center the sheet data horizontally, `false` by default
	 */
	horizontalCentered: boolean;
	/**
	 * 	Whether to center the sheet data vertically, `false` by default
	 */
	verticalCentered: boolean;
	/**
	 * Set Print Area for a sheet, e.g. `'A1:G20'`
	 */
	printArea: string;
	/**
	 * Repeat specific rows on every printed page, e.g. `'1:3'`
	 */
	printTitlesRow: string;
	/**
	 * Repeat specific columns on every printed page, e.g. `'A:C'`
	 */
	printTitlesColumn: string;
}
interface HeaderFooter {
	/**
	 * Set the value of differentFirst as true, which indicates that headers/footers for first page are different from the other pages, `false` by default
	 */
	differentFirst: boolean;
	/**
	 * Set the value of differentOddEven as true, which indicates that headers/footers for odd and even pages are different, `false` by default
	 */
	differentOddEven: boolean;
	/**
	 * Set header string for odd pages, could format the string and `null` by default
	 */
	oddHeader: string;
	/**
	 * Set footer string for odd pages, could format the string and `null` by default
	 */
	oddFooter: string;
	/**
	 * Set header string for even pages, could format the string and `null` by default
	 */
	evenHeader: string;
	/**
	 * Set footer string for even pages, could format the string and `null` by default
	 */
	evenFooter: string;
	/**
	 * Set header string for the first page, could format the string and `null` by default
	 */
	firstHeader: string;
	/**
	 * Set footer string for the first page, could format the string and `null` by default
	 */
	firstFooter: string;
}
type AutoFilter = string | {
	from: string | {
		row: number;
		column: number;
	};
	to: string | {
		row: number;
		column: number;
	};
};
interface WorksheetProtection {
	objects: boolean;
	scenarios: boolean;
	selectLockedCells: boolean;
	selectUnlockedCells: boolean;
	formatCells: boolean;
	formatColumns: boolean;
	formatRows: boolean;
	insertColumns: boolean;
	insertRows: boolean;
	insertHyperlinks: boolean;
	deleteColumns: boolean;
	deleteRows: boolean;
	sort: boolean;
	autoFilter: boolean;
	pivotTables: boolean;
	spinCount: number;
}
interface Image {
	extension: "jpeg" | "png" | "gif";
	base64?: string;
	filename?: string;
	buffer?: Buffer$1;
}
interface IAnchor {
	col: number;
	row: number;
	nativeCol: number;
	nativeRow: number;
	nativeColOff: number;
	nativeRowOff: number;
}
declare class Anchor implements IAnchor {
	col: number;
	nativeCol: number;
	nativeColOff: number;
	nativeRow: number;
	nativeRowOff: number;
	row: number;
	private readonly colWidth: number;
	private readonly rowHeight: number;
	worksheet: Worksheet;
	constructor(model?: IAnchor | object);
}
interface ImageRange {
	tl: Anchor;
	br: Anchor;
}
interface ImagePosition {
	tl: {
		col: number;
		row: number;
	};
	ext: {
		width: number;
		height: number;
	};
}
interface ImageHyperlinkValue {
	hyperlink: string;
	tooltip?: string;
}
interface Range extends Location {
	sheetName: string;
	tl: string;
	$t$l: string;
	br: string;
	$b$r: string;
	range: string;
	$range: string;
	shortRange: string;
	$shortRange: string;
	count: number;
	decode(): void;
	decode(v: Range): void;
	decode(v: string): void;
	decode(v: Location): void;
	decode(top: number, left: number, bottom: number, right: number, sheetName?: string): void;
	decode(tl: string, br: string, sheetName?: string): void;
	decode(v: [
		string,
		string
	]): void;
	decode(v: [
		string,
		string,
		string
	]): void;
	decode(v: [
		number,
		number,
		number,
		number
	]): void;
	decode(v: [
		number,
		number,
		number,
		number,
		string
	]): void;
	expand(top: number, left: number, bottom: number, right: number): void;
	expandRow(row: Row): void;
	expandToAddress(addressStr: string): void;
	toString(): string;
	intersects(other: Range): boolean;
	contains(addressStr: string): boolean;
	containsEx(address: Partial<{
		sheetName: string;
		row: number;
		col: number;
	}>): boolean;
}
interface RowBreak {
	id: number;
	max: number;
	min: number;
	man: number;
}
interface WorksheetModel {
	id: number;
	name: string;
	// dataValidations: this.dataValidations.model,
	properties: WorksheetProperties;
	pageSetup: Partial<PageSetup>;
	headerFooter: Partial<HeaderFooter>;
	rowBreaks: RowBreak[];
	views: WorksheetView[];
	autoFilter: AutoFilter;
	media: Media[];
	merges: Range["range"][];
}
type WorksheetState = "visible" | "hidden" | "veryHidden";
type CellIsOperators = "equal" | "greaterThan" | "lessThan" | "between";
type ContainsTextOperators = "containsText" | "containsBlanks" | "notContainsBlanks" | "containsErrors" | "notContainsErrors";
type TimePeriodTypes = "lastWeek" | "thisWeek" | "nextWeek" | "yesterday" | "today" | "tomorrow" | "last7Days" | "lastMonth" | "thisMonth" | "nextMonth";
type IconSetTypes = "5Arrows" | "5ArrowsGray" | "5Boxes" | "5Quarters" | "5Rating" | "4Arrows" | "4ArrowsGray" | "4Rating" | "4RedToBlack" | "4TrafficLights" | "NoIcons" | "3Arrows" | "3ArrowsGray" | "3Flags" | "3Signs" | "3Stars" | "3Symbols" | "3Symbols2" | "3TrafficLights1" | "3TrafficLights2" | "3Triangles";
type CfvoTypes = "percentile" | "percent" | "num" | "min" | "max" | "formula" | "autoMin" | "autoMax";
interface Cvfo {
	type: CfvoTypes;
	value?: number;
}
interface ConditionalFormattingBaseRule {
	priority: number;
	style?: Partial<Style>;
}
interface ExpressionRuleType extends ConditionalFormattingBaseRule {
	type: "expression";
	formulae?: any[];
}
interface CellIsRuleType extends ConditionalFormattingBaseRule {
	type: "cellIs";
	formulae?: any[];
	operator?: CellIsOperators;
}
interface Top10RuleType extends ConditionalFormattingBaseRule {
	type: "top10";
	rank: number;
	percent: boolean;
	bottom: boolean;
}
interface AboveAverageRuleType extends ConditionalFormattingBaseRule {
	type: "aboveAverage";
	aboveAverage: boolean;
}
interface ColorScaleRuleType extends ConditionalFormattingBaseRule {
	type: "colorScale";
	cfvo?: Cvfo[];
	color?: Partial<Color>[];
}
interface IconSetRuleType extends ConditionalFormattingBaseRule {
	type: "iconSet";
	showValue?: boolean;
	reverse?: boolean;
	custom?: boolean;
	iconSet?: IconSetTypes;
	cfvo?: Cvfo[];
}
interface ContainsTextRuleType extends ConditionalFormattingBaseRule {
	type: "containsText";
	operator?: ContainsTextOperators;
	text?: string;
}
interface TimePeriodRuleType extends ConditionalFormattingBaseRule {
	type: "timePeriod";
	timePeriod?: TimePeriodTypes;
}
interface DataBarRuleType extends ConditionalFormattingBaseRule {
	type: "dataBar";
	gradient?: boolean;
	minLength?: number;
	maxLength?: number;
	showValue?: boolean;
	border?: boolean;
	negativeBarColorSameAsPositive?: boolean;
	negativeBarBorderColorSameAsPositive?: boolean;
	axisPosition?: "auto" | "middle" | "none";
	direction?: "context" | "leftToRight" | "rightToLeft";
	cfvo?: Cvfo[];
}
type ConditionalFormattingRule = ExpressionRuleType | CellIsRuleType | Top10RuleType | AboveAverageRuleType | ColorScaleRuleType | IconSetRuleType | ContainsTextRuleType | TimePeriodRuleType | DataBarRuleType;
type RowValues = CellValue[] | {
	[key: string]: CellValue;
} | undefined | null;
interface ConditionalFormattingOptions {
	ref: string;
	rules: ConditionalFormattingRule[];
}
interface Worksheet {
	readonly id: number;
	name: string;
	readonly workbook: Workbook;
	readonly hasMerges: boolean;
	readonly dimensions: Range;
	/**
	 * Contains information related to how a worksheet is printed
	 */
	pageSetup: Partial<PageSetup>;
	/**
	 * Worksheet Header and Footer
	 */
	headerFooter: Partial<HeaderFooter>;
	/**
	 * Worksheet State
	 */
	state: WorksheetState;
	/**
	 * Worksheet Properties
	 */
	properties: WorksheetProperties;
	/**
	 * Open panes representing the sheet
	 */
	views: Array<Partial<WorksheetView>>;
	/**
	 * Apply an auto filter to your worksheet.
	 */
	autoFilter?: AutoFilter;
	destroy(): void;
	/**
	 * A count of the number of rows that have values. If a mid-document row is empty, it will not be included in the count.
	 */
	readonly actualRowCount: number;
	/**
	 * The total column size of the document. Equal to the maximum cell count from all of the rows
	 */
	readonly columnCount: number;
	/**
	 * Get the last column in a worksheet
	 */
	readonly lastColumn: Column | undefined;
	/**
	 * A count of the number of columns that have values.
	 */
	readonly actualColumnCount: number;
	getColumnKey(key: string): Column;
	setColumnKey(key: string, value: Column): void;
	deleteColumnKey(key: string): void;
	eachColumnKey(callback: (col: Column, index: number) => void): void;
	/**
	 * Access an individual columns by key, letter and 1-based column number
	 */
	getColumn(indexOrKey: number | string): Column;
	/**
	 * Cut one or more columns (columns to the right are shifted left)
	 * and optionally insert more
	 *
	 * If column properties have been definde, they will be cut or moved accordingly
	 *
	 * Known Issue: If a splice causes any merged cells to move, the results may be unpredictable
	 *
	 * Also: If the worksheet has more rows than values in the colulmn inserts,
	 * the rows will still be shifted as if the values existed
	 */
	spliceColumns(start: number, count: number, ...insert: any[][]): void;
	/**
	 * Add column headers and define column keys and widths.
	 *
	 * Note: these column structures are a workbook-building convenience only,
	 * apart from the column width, they will not be fully persisted.
	 */
	columns: Array<Partial<Column>>;
	/**
	 * The total row size of the document. Equal to the row number of the last row that has values.
	 */
	readonly rowCount: number;
	/**
	 * Get the last editable row in a worksheet (or undefined if there are none)
	 */
	readonly lastRow: Row | undefined;
	/**
	 * Tries to find and return row for row no, else undefined
	 *
	 * @param row The 1-index row number
	 */
	findRow(row: number): Row | undefined;
	/**
	 * Tries to find and return rows for row no start and length, else undefined
	 *
	 * @param start The 1-index starting row number
	 * @param length The length of the expected array
	 */
	findRows(start: number, length: number): Row[] | undefined;
	/**
	 * Cut one or more rows (rows below are shifted up)
	 * and optionally insert more
	 *
	 * Known Issue: If a splice causes any merged cells to move, the results may be unpredictable
	 */
	spliceRows(start: number, count: number, ...insert: any[][]): void;
	/**
	 * Add a couple of Rows by key-value, after the last current row, using the column keys,
	 * or add a row by contiguous Array (assign to columns A, B & C)
	 */
	addRow(data: any[] | any, style?: string): Row;
	/**
	 * Add multiple rows by providing an array of arrays or key-value pairs
	 */
	addRows(rows: any[], style?: string): Row[];
	/**
	 * Insert a Row by key-value, at the position (shifiting down all rows from position),
	 * using the column keys, or add a row by contiguous Array (assign to columns A, B & C)
	 */
	insertRow(pos: number, value: any[] | any, style?: string): Row;
	/**
	 * Insert multiple rows at position (shifiting down all rows from position)
	 * by providing an array of arrays or key-value pairs
	 */
	insertRows(pos: number, values: any[], style?: string): Row[];
	/**
	 * Duplicate rows and insert new rows
	 */
	duplicateRow(rowNum: number, count: number, insert: boolean): void;
	/**
	 * Get or create row by 1-based index
	 */
	getRow(index: number): Row;
	/**
	 * Get or create rows by 1-based index
	 */
	getRows(start: number, length: number): Row[] | undefined;
	/**
	 * Iterate over all rows that have values in a worksheet
	 */
	eachRow(callback: (row: Row, rowNumber: number) => void): void;
	/**
	 * Iterate over all rows (including empty rows) in a worksheet
	 */
	eachRow(opt: {
		includeEmpty: boolean;
	}, callback: (row: Row, rowNumber: number) => void): void;
	/**
	 * return all rows as sparse array
	 */
	getSheetValues(): RowValues[];
	/**
	 * returns the cell at [r,c] or address given by r. If not found, return undefined
	 */
	findCell(r: number | string, c: number | string): Cell | undefined;
	/**
	 * Get or create cell
	 */
	getCell(r: number | string, c?: number | string): Cell;
	/**
	 * Merge cells, either:
	 *
	 * tlbr string, e.g. `'A4:B5'`
	 *
	 * tl string, br string, e.g. `'G10', 'H11'`
	 *
	 * t, l, b, r numbers, e.g. `10,11,12,13`
	 */
	mergeCells(): void;
	mergeCells(v: Range): void;
	mergeCells(v: string): void;
	mergeCells(v: Location): void;
	mergeCells(top: number, left: number, bottom: number, right: number, sheetName?: string): void;
	mergeCells(tl: string, br: string, sheetName?: string): void;
	mergeCells(v: [
		string,
		string
	]): void;
	mergeCells(v: [
		string,
		string,
		string
	]): void;
	mergeCells(v: [
		number,
		number,
		number,
		number
	]): void;
	mergeCells(v: [
		number,
		number,
		number,
		number,
		string
	]): void;
	mergeCellsWithoutStyle(): void;
	mergeCellsWithoutStyle(v: Range): void;
	mergeCellsWithoutStyle(v: string): void;
	mergeCellsWithoutStyle(v: Location): void;
	mergeCellsWithoutStyle(top: number, left: number, bottom: number, right: number, sheetName?: string): void;
	mergeCellsWithoutStyle(tl: string, br: string, sheetName?: string): void;
	mergeCellsWithoutStyle(v: [
		string,
		string
	]): void;
	mergeCellsWithoutStyle(v: [
		string,
		string,
		string
	]): void;
	mergeCellsWithoutStyle(v: [
		number,
		number,
		number,
		number
	]): void;
	mergeCellsWithoutStyle(v: [
		number,
		number,
		number,
		number,
		string
	]): void;
	/**
	 * unmerging the cells breaks the style links
	 */
	unMergeCells(): void;
	unMergeCells(v: Range): void;
	unMergeCells(v: string): void;
	unMergeCells(v: Location): void;
	unMergeCells(top: number, left: number, bottom: number, right: number, sheetName?: string): void;
	unMergeCells(tl: string, br: string, sheetName?: string): void;
	unMergeCells(v: [
		string,
		string
	]): void;
	unMergeCells(v: [
		string,
		string,
		string
	]): void;
	unMergeCells(v: [
		number,
		number,
		number,
		number
	]): void;
	unMergeCells(v: [
		number,
		number,
		number,
		number,
		string
	]): void;
	fillFormula(range: Range | string | Location, formula: string, results?: ((r: number, c: number) => string | number) | number[] | number[][]): void;
	/**
	 * Using the image id from `Workbook.addImage`, set the background to the worksheet
	 */
	addBackgroundImage(imageId: number): void;
	getBackgroundImageId(): string;
	/**
	 * Using the image id from `Workbook.addImage`,
	 * embed an image within the worksheet to cover a range
	 */
	addImage(imageId: number, range: string | {
		editAs?: string;
	} & ImageRange & {
		hyperlinks?: ImageHyperlinkValue;
	} | {
		editAs?: string;
	} & ImagePosition & {
		hyperlinks?: ImageHyperlinkValue;
	}): void;
	getImages(): Array<{
		type: "image";
		imageId: string;
		range: ImageRange;
	}>;
	commit(): void;
	model: WorksheetModel;
	/**
	 * Worksheet protection
	 */
	protect(password: string, options: Partial<WorksheetProtection>): Promise<void>;
	unprotect(): void;
	/**
	 * Add a new table and return a reference to it
	 */
	addTable(tableProperties: TableProperties): Table;
	/**
	 * fetch table by name or id
	 */
	getTable(name: string): Table;
	/**
	 * delete table by name or id
	 */
	removeTable(name: string): void;
	/**
	 *  fetch table
	 */
	getTables(): [
		Table,
		void
	][];
	/**
	 * add conditionalFormattingOptions
	 */
	addConditionalFormatting(cf: ConditionalFormattingOptions): void;
	/**
	 * delete conditionalFormattingOptions
	 */
	removeConditionalFormatting(filter: any): void;
}
interface CalculationProperties {
	/**
	 * Whether the application shall perform a full recalculation when the workbook is opened
	 */
	fullCalcOnLoad: boolean;
}
interface WorksheetProperties {
	/**
	 * Color of the tab
	 */
	tabColor: Partial<Color>;
	/**
	 * The worksheet column outline level (default: 0)
	 */
	outlineLevelCol: number;
	/**
	 * The worksheet row outline level (default: 0)
	 */
	outlineLevelRow: number;
	/**
	 * The outline properties which controls how it will summarize rows and columns
	 */
	outlineProperties: {
		summaryBelow: boolean;
		summaryRight: boolean;
	};
	/**
	 * Default row height (default: 15)
	 */
	defaultRowHeight: number;
	/**
	 * Default column width (optional)
	 */
	defaultColWidth?: number;
	/**
	 * default: 55
	 */
	dyDescent: number;
	showGridLines: boolean;
}
interface AddWorksheetOptions {
	properties: Partial<WorksheetProperties>;
	pageSetup: Partial<PageSetup>;
	headerFooter: Partial<HeaderFooter>;
	views: Array<Partial<WorksheetView>>;
	state: WorksheetState;
}
interface WorkbookProperties {
	/**
	 * Set workbook dates to 1904 date system
	 */
	date1904: boolean;
}
interface JSZipGeneratorOptions {
	/**
	 * @default DEFLATE
	 */
	compression: "STORE" | "DEFLATE";
	compressionOptions: null | {
		/**
		 * @default 6
		 */
		level: number;
	};
}
interface XlsxReadOptions {
	/**
	 * The list of XML node names to ignore while parsing an XLSX file
	 */
	ignoreNodes: string[];
}
interface XlsxWriteOptions extends stream.xlsx.WorkbookWriterOptions {
	/**
	 * The option passed to JsZip#generateAsync(options)
	 */
	zip: Partial<JSZipGeneratorOptions>;
}
interface Xlsx {
	/**
	 * read from a file
	 */
	readFile(path: string, options?: Partial<XlsxReadOptions>): Promise<Workbook>;
	/**
	 * read from a stream
	 * @param stream
	 */
	read(stream: import("stream").Stream, options?: Partial<XlsxReadOptions>): Promise<Workbook>;
	/**
	 * load from an array buffer
	 * @param buffer
	 */
	load(buffer: Buffer$1, options?: Partial<XlsxReadOptions>): Promise<Workbook>;
	/**
	 * write to a buffer
	 */
	writeBuffer(options?: Partial<XlsxWriteOptions>): Promise<Buffer$1>;
	/**
	 * write to a file
	 */
	writeFile(path: string, options?: Partial<XlsxWriteOptions>): Promise<void>;
	/**
	 * write to a stream
	 */
	write(stream: import("stream").Stream, options?: Partial<XlsxWriteOptions>): Promise<void>;
}
type HeaderArray = (string | undefined | null)[];
type HeaderTransformFunction = (headers: HeaderArray) => HeaderArray;
interface FastCsvParserOptionsArgs {
	objectMode: boolean;
	delimiter: string;
	quote: string | null;
	escape: string;
	headers: boolean | HeaderTransformFunction | HeaderArray;
	renameHeaders: boolean;
	ignoreEmpty: boolean;
	comment: string;
	strictColumnHandling: boolean;
	discardUnmappedColumns: boolean;
	trim: boolean;
	ltrim: boolean;
	rtrim: boolean;
	encoding: string;
	maxRows: number;
	skipLines: number;
	skipRows: number;
}
interface QuoteColumnMap {
	[s: string]: boolean;
}
declare type QuoteColumns = boolean | boolean[] | QuoteColumnMap;
interface RowMap {
	[key: string]: any;
}
declare type RowHashArray = [
	string,
	any
][];
declare type RowArray = string[];
declare type Rows = RowArray | RowMap | RowHashArray;
declare type RowTransformCallback = (error?: Error | null, row?: Rows) => void;
interface RowTransformFunction {
	(row: Rows, callback: RowTransformCallback): void;
	(row: Rows): Rows;
}
interface FastCsvFormatterOptionsArgs {
	objectMode: boolean;
	delimiter: string;
	rowDelimiter: string;
	quote: string | boolean;
	escape: string;
	quoteColumns: QuoteColumns;
	quoteHeaders: QuoteColumns;
	headers: null | boolean | string[];
	includeEndRowDelimiter: boolean;
	writeBOM: boolean;
	transform: RowTransformFunction;
	alwaysWriteHeaders: boolean;
}
interface CsvReadOptions {
	dateFormats: string[];
	map(value: any, index: number): any;
	sheetName: string;
	parserOptions: Partial<FastCsvParserOptionsArgs>;
}
interface CsvWriteOptions {
	dateFormat: string;
	dateUTC: boolean;
	sheetName: string;
	sheetId: number;
	encoding: string;
	map(value: any, index: number): any;
	includeEmptyRows: boolean;
	formatterOptions: Partial<FastCsvFormatterOptionsArgs>;
}
interface Csv {
	/**
	 * read from a file
	 */
	readFile(path: string, options?: Partial<CsvReadOptions>): Promise<Worksheet>;
	/**
	 * read from a stream
	 */
	read(stream: import("stream").Stream, options?: Partial<CsvReadOptions>): Promise<Worksheet>;
	/**
	 * Create input stream for reading
	 */
	createInputStream(options?: Partial<CsvReadOptions>): import("events").EventEmitter;
	/**
	 * write to a buffer
	 */
	writeBuffer(options?: Partial<CsvWriteOptions>): Promise<Buffer$1>;
	/**
	 * write to a file
	 */
	writeFile(path: string, options?: Partial<CsvWriteOptions>): Promise<void>;
	/**
	 * write to a stream
	 */
	write(stream: import("stream").Stream, options?: Partial<CsvWriteOptions>): Promise<void>;
}
interface Media {
	type: string; // image,background
	name: string;
	extension: string;
	buffer: Buffer$1;
}
interface Address {
	sheetName?: string;
	address: string;
	col: string;
	row: string;
	$col$row: string;
}
interface Location {
	top: number;
	left: number;
	bottom: number;
	right: number;
}
interface CellMatrix {
	addCell(addressStr: string): void;
	getCell(addressStr: string): Cell;
	findCell(addressStr: string): Cell | undefined;
	findCellAt(sheetName: string, rowNumber: number, colNumber: number): Cell | undefined;
	addCellEx(address: string | Location): void;
	getCellEx(address: string | Location): Cell;
	findCellEx(address: string | Location, create: boolean): Cell | undefined;
	getCellAt(sheetName: string, rowNumber: number, colNumber: number): Cell;
	removeCellEx(address: string | Location): void;
	forEach(callback: (cell: Cell) => void): void;
	map<T>(callback: (cell: Cell) => T): T[];
	findSheet(address: string | Location, create: boolean): Cell[] | undefined;
	findSheetRow(sheet: Cell[][], address: string | Location, create: boolean): Row | undefined;
	findRowCell(row: any[], address: Address, create: boolean): Cell | undefined;
}
interface DefinedNamesRanges {
	name: string;
	ranges: string[];
}
type DefinedNamesModel = DefinedNamesRanges[];
interface DefinedNames {
	getMatrix(name: string): CellMatrix;
	// add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2
	add(locStr: string, name?: string): void;
	addEx(location: string | Location, name: string): Cell;
	remove(locStr: string | Location, name: string): void;
	removeEx(location: string | Location, name: string): void;
	removeAllNames(location: string | Location): void;
	forEach(callback: (name: string, cell: Cell) => void): void;
	// get all the names of a cell
	getNames(addressStr: string): string[];
	getNamesEx(address: string): string[];
	getRanges(name: string, matrix?: CellMatrix): DefinedNamesRanges;
	model: DefinedNamesModel;
}
interface WorkbookModel {
	creator: string;
	lastModifiedBy: string;
	lastPrinted: Date;
	created: Date;
	modified: Date;
	properties: WorkbookProperties;
	worksheets: Worksheet[];
	sheets: WorksheetModel[];
	definedNames: DefinedNamesModel;
	views: WorkbookView[];
	company: string;
	manager: string;
	title: string;
	subject: string;
	keywords: string;
	category: string;
	description: string;
	language: string;
	revision: Date;
	contentStatus: string;
	themes: string[];
	media: Media[];
}
declare class Workbook {
	category: string;
	company: string;
	creator: string;
	description: string;
	keywords: string;
	lastModifiedBy: string;
	created: Date;
	manager: string;
	modified: Date;
	lastPrinted: Date;
	properties: WorkbookProperties;
	subject: string;
	title: string;
	/**
	 * Workbook calculation Properties
	 */
	calcProperties: CalculationProperties;
	/**
	 * xlsx file format operations
	 */
	readonly xlsx: Xlsx;
	/**
	 * csv file format operations
	 */
	readonly csv: Csv;
	readonly nextId: number;
	readonly definedNames: DefinedNames;
	model: WorkbookModel;
	/**
	 * The Workbook views controls how many separate windows Excel will open when viewing the workbook.
	 */
	views: WorkbookView[];
	/**
	 * return a clone of worksheets in order
	 */
	worksheets: Worksheet[];
	/**
	 * Add a new worksheet and return a reference to it
	 */
	addWorksheet(name?: string, options?: Partial<AddWorksheetOptions>): Worksheet;
	removeWorksheetEx(worksheet: Worksheet): void;
	removeWorksheet(indexOrName: number | string): void;
	/**
	 * fetch sheet by name or id
	 */
	getWorksheet(indexOrName?: number | string): Worksheet | undefined;
	/**
	 * Iterate over all sheets.
	 *
	 * Note: `workbook.worksheets.forEach` will still work but this is better.
	 */
	eachSheet(callback: (worksheet: Worksheet, id: number) => void): void;
	clearThemes(): void;
	/**
	 * Add Image to Workbook and return the id
	 */
	addImage(img: Image): number;
	getImage(id: number): Image;
}
interface TableStyleProperties {
	/**
	 * The colour theme of the table
	 * @default 'TableStyleMedium2'
	 */
	theme?: "TableStyleDark1" | "TableStyleDark10" | "TableStyleDark11" | "TableStyleDark2" | "TableStyleDark3" | "TableStyleDark4" | "TableStyleDark5" | "TableStyleDark6" | "TableStyleDark7" | "TableStyleDark8" | "TableStyleDark9" | "TableStyleLight1" | "TableStyleLight10" | "TableStyleLight11" | "TableStyleLight12" | "TableStyleLight13" | "TableStyleLight14" | "TableStyleLight15" | "TableStyleLight16" | "TableStyleLight17" | "TableStyleLight18" | "TableStyleLight19" | "TableStyleLight2" | "TableStyleLight20" | "TableStyleLight21" | "TableStyleLight3" | "TableStyleLight4" | "TableStyleLight5" | "TableStyleLight6" | "TableStyleLight7" | "TableStyleLight8" | "TableStyleLight9" | "TableStyleMedium1" | "TableStyleMedium10" | "TableStyleMedium11" | "TableStyleMedium12" | "TableStyleMedium13" | "TableStyleMedium14" | "TableStyleMedium15" | "TableStyleMedium16" | "TableStyleMedium17" | "TableStyleMedium18" | "TableStyleMedium19" | "TableStyleMedium2" | "TableStyleMedium20" | "TableStyleMedium21" | "TableStyleMedium22" | "TableStyleMedium23" | "TableStyleMedium24" | "TableStyleMedium25" | "TableStyleMedium26" | "TableStyleMedium27" | "TableStyleMedium28" | "TableStyleMedium3" | "TableStyleMedium4" | "TableStyleMedium5" | "TableStyleMedium6" | "TableStyleMedium7" | "TableStyleMedium8" | "TableStyleMedium9";
	/**
	  * Highlight the first column (bold)
	  * @default false
	  */
	showFirstColumn?: boolean;
	/**
	  * Highlight the last column (bold)
	  * @default false
	  */
	showLastColumn?: boolean;
	/**
	  * Alternate rows shown with background colour
	  * @default false
	  */
	showRowStripes?: boolean;
	/**
	  * Alternate rows shown with background colour
	  * @default false
	  */
	showColumnStripes?: boolean;
}
interface TableColumnProperties {
	/**
	  * The name of the column, also used in the header
	  */
	name: string;
	/**
	  * Switches the filter control in the header
	  * @default false
	  */
	filterButton?: boolean;
	/**
	  * Label to describe the totals row (first column)
	  * @default 'Total'
	  */
	totalsRowLabel?: string;
	/**
	  * Name of the totals function
	  * @default 'none'
	  */
	totalsRowFunction?: "none" | "average" | "countNums" | "count" | "max" | "min" | "stdDev" | "var" | "sum" | "custom";
	/**
	  * Optional formula for custom functions
	  */
	totalsRowFormula?: string;
}
interface TableProperties {
	/**
	 * The name of the table
	 */
	name: string;
	/**
	 * The display name of the table
	 */
	displayName?: string;
	/**
	 * Top left cell of the table
	 */
	ref: string;
	/**
	 * Show headers at top of table
	 * @default true
	 */
	headerRow?: boolean;
	/**
	 * Show totals at bottom of table
	 * @default false
	 */
	totalsRow?: boolean;
	/**
	 * Extra style properties
	 * @default {}
	 */
	style?: TableStyleProperties;
	/**
	 * Column definitions
	 */
	columns: TableColumnProperties[];
	/**
	 * Rows of data
	 */
	rows: any[][];
}
type TableColumn = Required<TableColumnProperties>;
interface Table extends Required<TableProperties> {
	/**
	 * Commit changes
	 */
	commit: () => void;
	/**
	 * Remove a rows of data
	 */
	removeRows: (rowIndex: number, count: number) => void;
	/**
	 * Add a row of data, either insert at rowNumber or append
	 */
	addRow: (values: any[], rowNumber?: number) => void;
	/**
	 * Get column
	 */
	getColumn: (colIndex: number) => TableColumn;
	/**
	 * Add a new column, including column defn and values
	 * inserts at colNumber or adds to the right
	 */
	addColumn: (column: TableColumnProperties, values: any[], colIndex: number) => void;
	/**
	 * Remove a column with data
	 */
	removeColumns: (colIndex: number, count: number) => void;
}
declare namespace config {
	function setValue(key: "promise", promise: any): void;
}
declare namespace stream {
	namespace xlsx {
		interface WorkbookWriterOptions {
			/**
			 * Specifies a writable stream to write the XLSX workbook to.
			 */
			stream: import("stream").Stream;
			/**
			 * 	If stream not specified, this field specifies the path to a file to write the XLSX workbook to.
			 */
			filename: string;
			/**
			 * 	Specifies whether to use shared strings in the workbook. Default is false
			 */
			useSharedStrings: boolean;
			/**
			 * Specifies whether to add style information to the workbook.
			 * Styles can add some performance overhead. Default is false
			 */
			useStyles: boolean;
		}
		interface ArchiverZipOptions {
			comment: string;
			forceLocalTime: boolean;
			forceZip64: boolean;
			store: boolean;
			zlib: Partial<ZlibOptions>;
		}
		interface ZlibOptions {
			/**
			 * @default constants.Z_NO_FLUSH
			 */
			flush: number;
			/**
			 * @default constants.Z_FINISH
			 */
			finishFlush: number;
			/**
			 * @default 16*1024
			 */
			chunkSize: number;
			windowBits: number;
			level: number; // compression only
			memLevel: number; // compression only
			strategy: number; // compression only
			dictionary: Buffer$1 | NodeJS.TypedArray | DataView | ArrayBuffer; // deflate/inflate only, empty dictionary by default
		}
		interface WorkbookStreamWriterOptions extends WorkbookWriterOptions {
			/**
			 * Specifies whether to add style information to the workbook.
			 * Styles can add some performance overhead. Default is false
			 */
			zip: Partial<ArchiverZipOptions>;
		}
		class WorkbookWriter extends Workbook {
			constructor(options: Partial<WorkbookStreamWriterOptions>);
			// commit all worksheets, then add suplimentary files
			commit(): Promise<void>;
			addStyles(): Promise<void>;
			addThemes(): Promise<void>;
			addOfficeRels(): Promise<void>;
			addContentTypes(): Promise<void>;
			addApp(): Promise<void>;
			addCore(): Promise<void>;
			addSharedStrings(): Promise<void>;
			addWorkbookRels(): Promise<void>;
			addWorkbook(): Promise<void>;
		}
		interface WorkbookStreamReaderOptions {
			/**
			 * @default 'emit'
			 */
			worksheets?: "emit" | "ignore";
			/**
			 * @default 'cache'
			 */
			sharedStrings?: "cache" | "emit" | "ignore";
			/**
			 * @default 'ignore'
			 */
			hyperlinks?: "cache" | "emit" | "ignore";
			/**
			 * @default 'ignore'
			 */
			styles?: "cache" | "ignore";
			/**
			 * @default 'ignore'
			 */
			entries?: "emit" | "ignore";
		}
		class WorkbookReader extends Workbook {
			constructor(input: string | import("stream").Stream, options: Partial<WorkbookStreamReaderOptions>);
			read(): Promise<void>;
			[Symbol.asyncIterator](): AsyncGenerator<WorksheetReader>;
			parse(): AsyncIterator<any>;
		}
		interface WorksheetReaderOptions {
			workbook: Workbook;
			id: number;
			entry: import("stream").Stream;
			options: WorkbookStreamReaderOptions;
		}
		class WorksheetReader {
			constructor(options: WorksheetReaderOptions);
			read(): Promise<void>;
			[Symbol.asyncIterator](): AsyncGenerator<Row>;
			parse(): AsyncIterator<Array<any>>;
			dimensions(): number;
			columns(): number;
			getColumn(c: number): Column;
		}
	}
}
type Cells = Record<string, string>;
type TableKey = string | number;
type Table$1 = Record<TableKey, Record<string, string>>;
type MultiTable = Record<TableKey, Record<string, string>[]>;
type CellTable = Record<TableKey, Record<string, exceljs.Cell>>;
type MultiCellTable = Record<TableKey, Record<string, exceljs.Cell>[]>;
declare class Sheet {
	sheet: exceljs.Worksheet;
	name: string;
	id: number;
	constructor(sheet: exceljs.Worksheet);
	private _cells?;
	/**
	 * 存放所有的单元格，使用 `sheet.cells['A1']` 来获取单元格的值
	 */
	get cells(): Cells;
	private createCells;
	private guessTableOffset;
	/**
	 * 已某个单元格为锚点，创建一个key-value的表格。
	 * 如果不提供参数，会自动猜测一个合适的位置。
	 * @param offset 锚点位置，如 `"B2"`
	 * @param skip 标题下额外跳过的行数（可能是标题的描述）
	 */
	makeCellTable(offset?: string, skip?: number): CellTable;
	/**
	 * 已某个单元格为锚点，创建一个key-value的表格。
	 * 如果不提供参数，会自动猜测一个合适的位置。
	 * @param offset 锚点位置，如 `"B2"`
	 * @param skip 标题下额外跳过的行数（可能是标题的描述）
	 */
	makeTable(offset?: string, skip?: number): Table$1;
	/**
	 * 已某个单元格为锚点，创建一个key-value[]的多维表格。
	 * 与 `makeTable` 不同，可以一个对象可以保存多行的数据。
	 * 如果不提供参数，会自动猜测一个合适的位置。
	 * @param offset 锚点位置，如 `"B2"`
	 * @param skip 标题下额外跳过的行数（可能是标题的描述）
	 */
	makeMultiCellTable(offset?: string, skip?: number): MultiCellTable;
	/**
	 * 已某个单元格为锚点，创建一个key-value[]的多维表格。
	 * 与 `makeTable` 不同，可以一个对象可以保存多行的数据。
	 * 如果不提供参数，会自动猜测一个合适的位置。
	 * @param offset 锚点位置，如 `"B2"`
	 * @param skip 标题下额外跳过的行数（可能是标题的描述）
	 */
	makeMultiTable(offset?: string, skip?: number): MultiTable;
}
declare class Excel {
	private workbook;
	private uri?;
	/**
	 *
	 * @param fileUri 文件路径
	 */
	loadFile(fileUri: vscode.Uri): Promise<boolean>;
	private proxySheet;
	/**
	 * 获取指定的sheet
	 * @param indexOrName sheet的索引或名称
	 */
	getSheet(indexOrName?: number | string): y3.excel.Sheet | undefined;
	getAllSheets(): Sheet[];
}
declare namespace Table$2 {
	const path: {
		readonly toCN: {
			readonly editorunit: "\u5355\u4F4D";
			readonly soundall: "\u58F0\u97F3";
			readonly abilityall: "\u6280\u80FD";
			readonly editordecoration: "\u88C5\u9970\u7269";
			readonly editordestructible: "\u53EF\u7834\u574F\u7269";
			readonly editoritem: "\u7269\u54C1";
			readonly modifierall: "\u9B54\u6CD5\u6548\u679C";
			readonly projectileall: "\u6295\u5C04\u7269";
			readonly technologyall: "\u79D1\u6280";
		};
		readonly fromCN: {
			readonly 单位: "editorunit";
			readonly 声音: "soundall";
			readonly 技能: "abilityall";
			readonly 装饰物: "editordecoration";
			readonly 可破坏物: "editordestructible";
			readonly 物品: "editoritem";
			readonly 魔法效果: "modifierall";
			readonly 投射物: "projectileall";
			readonly 科技: "technologyall";
		};
		readonly toName: {
			readonly editorunit: "unit";
			readonly soundall: "sound";
			readonly abilityall: "ability";
			readonly editordecoration: "decoration";
			readonly editordestructible: "destructible";
			readonly editoritem: "item";
			readonly modifierall: "modifier";
			readonly projectileall: "projectile";
			readonly technologyall: "technology";
		};
		readonly fromName: {
			readonly unit: "editorunit";
			readonly sound: "soundall";
			readonly ability: "abilityall";
			readonly decoration: "editordecoration";
			readonly destructible: "editordestructible";
			readonly item: "editoritem";
			readonly modifier: "modifierall";
			readonly projectile: "projectileall";
			readonly technology: "technologyall";
		};
	};
	const name: {
		readonly toCN: {
			readonly unit: "\u5355\u4F4D";
			readonly decoration: "\u88C5\u9970\u7269";
			readonly item: "\u7269\u54C1";
			readonly ability: "\u6280\u80FD";
			readonly modifier: "\u9B54\u6CD5\u6548\u679C";
			readonly projectile: "\u6295\u5C04\u7269";
			readonly technology: "\u79D1\u6280";
			readonly destructible: "\u53EF\u7834\u574F\u7269";
			readonly sound: "\u58F0\u97F3";
		};
		readonly fromCN: {
			readonly 单位: "unit";
			readonly 装饰物: "decoration";
			readonly 物品: "item";
			readonly 技能: "ability";
			readonly 魔法效果: "modifier";
			readonly 投射物: "projectile";
			readonly 科技: "technology";
			readonly 可破坏物: "destructible";
			readonly 声音: "sound";
		};
	};
	const type: {
		readonly toLuaType: {
			readonly 100000: "number";
			readonly 100001: "boolean";
			readonly 100002: "integer";
			readonly 100003: "string";
			readonly 100004: "Point";
			readonly 100006: "Unit";
			readonly 100010: "UnitKey";
			readonly 100011: "table";
			readonly 100014: "Ability";
			readonly 100025: "Player";
			readonly 100026: "UnitGroup";
			readonly 100027: "PlayerGroup";
			readonly 100031: "Item";
			readonly 100032: "ItemKey";
			readonly 100039: "AbilityKey";
			readonly 100263: "Mover";
		};
		readonly toName: {
			readonly 100000: "\u5B9E\u6570";
			readonly 100001: "\u5E03\u5C14";
			readonly 100002: "\u6574\u6570";
			readonly 100003: "\u5B57\u7B26\u4E32";
			readonly 100004: "\u70B9";
			readonly 100006: "\u5355\u4F4D";
			readonly 100010: "\u5355\u4F4D\u7C7B\u578B";
			readonly 100011: "\u8868";
			readonly 100014: "\u6280\u80FD";
			readonly 100025: "\u73A9\u5BB6";
			readonly 100026: "\u5355\u4F4D\u7EC4";
			readonly 100027: "\u73A9\u5BB6\u7EC4";
			readonly 100031: "\u7269\u54C1";
			readonly 100032: "\u7269\u54C1\u7C7B\u578B";
			readonly 100039: "\u6280\u80FD\u7C7B\u578B";
			readonly 100263: "\u8FD0\u52A8\u5668";
		};
		readonly etype: {
			readonly 0: "\u5B57\u7B26\u4E32";
			readonly 1: "\u6574\u6570";
			readonly 2: "\u5B9E\u6570";
			readonly 4: "\u5E03\u5C14";
		};
		readonly type: {
			readonly 0: "\u5B57\u7B26\u4E32";
			readonly 1: "\u5B9E\u6570";
			readonly 2: "\u6574\u6570";
			readonly 3: "\u5E03\u5C14";
		};
	};
	type Path = keyof typeof path.toCN;
	type NameEN = keyof typeof name.toCN;
	type NameCN = keyof typeof name.fromCN;
	type TypeID = keyof typeof type.toLuaType;
}
type Row$1 = Record<string, string>;
type ReaderFunc<T> = (...rows: Row$1[]) => NoInfer<T> | undefined;
type AsFunc<T> = (content: string, source?: T, ...extraContents: string[]) => NoInfer<T> | undefined;
declare class AsRule<T> {
	private as?;
	constructor(as?: As<T> | undefined);
	protected value: any;
	applyAs(content: any, source?: T, ...extraContents: any[]): T | undefined;
	private _default?;
	/**
	 * 如果值为 `undefined`，则使用此默认值。
	 * @param value 默认值。
	 * @returns
	 */
	default(value?: T): this;
	private _finally?;
	/**
	 * 对数据进行最后的处理。
	 * @param callback 处理函数。
	 * @returns
	 */
	finally(callback: (value?: T) => T): this;
}
declare class ReaderRule<T> extends AsRule<T> {
	private reader;
	constructor(reader: ReaderFunc<T>, as?: As<T>);
	applyReader(rows: Row$1 | Row$1[], source?: T): T | undefined;
}
type Reader<T> = string | undefined | ReaderFunc<T> | ReaderRule<T>;
type As<T> = AsFunc<T> | AsRule<T>;
type EditorDataField<N extends y3.consts.Table.NameCN> = keyof y3.table.EditorData<N>;
type EditorDataFieldType<N extends y3.consts.Table.NameCN, F extends EditorDataField<N>> = y3.table.EditorData<N>[F];
type RuleData<N extends y3.consts.Table.NameCN> = {
	[key in EditorDataField<N>]: Reader<EditorDataFieldType<N, key>>;
};
type RuleField<N extends y3.consts.Table.NameCN> = {
	[key in EditorDataField<N>]: key;
};
declare class Rule<N extends y3.consts.Table.NameCN> {
	tableName: N;
	path: vscode.Uri;
	sheetName?: (number | string) | undefined;
	rule: this;
	/**
	 * excel的字段读取器。
	 */
	reader: {
		/**
		 * excel的每一个对象都会调用此回调哈数，你需要返回最终写入表中的值。
		 * 返回 `undefined` 时表示不做修改（使用物编里原来的值）。
		 * @param callback 一个回调函数，需要你返回最终写入表中的值。
		 * @returns
		 */
		readonly rule: <T>(callback: ReaderFunc<T>) => ReaderRule<T>;
		/**
		 * 将值视为数字。
		 * @param title 列标题
		 * @param defaultValue 默认值，如果不传表示不做修改（使用物编里原来的值）。
		 * @returns
		 */
		readonly number: (title: string, defaultValue?: number) => ReaderRule<number>;
		/**
		 * 将值视为整数。
		 */
		readonly integer: (title: string, defaultValue?: number) => ReaderRule<number>;
		/**
		 * 将值视为布尔值。
		 * @param title 列标题
		 * @param defaultValue 默认值，如果不传表示不做修改（使用物编里原来的值）。
		 * @returns
		 */
		readonly boolean: (title: string, defaultValue?: boolean) => ReaderRule<boolean>;
		/**
		 * 将值视为数组。如果设置了 `default`，则会用默认值填充数组。
		 * @param title 列标题
		 * @param separator 分割符
		 * @param converter 数组中的每一项还会调用此函数再转换一次
		 * @returns
		 */
		readonly string: (title: string, defaultValue?: string) => ReaderRule<string>;
		/**
		 * 将值视为数组。如果设置了 `default`，则会用默认值填充数组。
		 * @param title 列标题
		 * @param separator 分割符
		 * @param converter 数组中的每一项还会调用此函数再转换一次
		 * @returns
		 */
		readonly split: <T = string>(title: string, separator: string | RegExp, converter?: (value: string) => T) => ReaderRule<T[]>;
	};
	/**
	 * 数据转换器
	 */
	as: {
		/**
		 * 将值视为数字。
		 * @param value 值
		 * @param defaultValue 默认值，如果不传表示不做修改（使用物编里原来的值）。
		 * @returns
		 */
		readonly number: (defaultValue?: number) => AsRule<number>;
		/**
		 * 将值视为整数
		 */
		readonly integer: (defaultValue?: number) => AsRule<number>;
		/**
		 * 将值视为字符串。
		 * @param value 值
		 * @param defaultValue 默认值，如果不传表示不做修改（使用物编里原来的值）。
		 * @returns
		 */
		readonly string: (defaultValue?: string) => AsRule<string>;
		/**
		 * 将值视为布尔值。
		 * @param value 值
		 * @param defaultValue 默认值，如果不传表示不做修改（使用物编里原来的值）。
		 * @returns
		 */
		readonly boolean: (defaultValue?: boolean) => AsRule<boolean>;
		/**
		 * 将值视为数组。如果设置了 `default`，则会用默认值填充数组。
		 * @param title 列标题
		 * @param separator 分割符
		 * @param converter 数组中的每一项还会调用此函数再转换一次
		 * @returns
		 */
		readonly split: <T = string>(separator: string | RegExp, converter?: (value: string) => T) => AsRule<T[]>;
	};
	private _actions;
	/**
	 * 描述字段从表里的哪些列获取数据。
	 */
	data: RuleData<N>;
	field: RuleField<N>;
	constructor(tableName: N, path: vscode.Uri, sheetName?: (number | string) | undefined);
	/**
	 * 表格中的偏移量，如 `A1`、`B2` 等。如果不提供会尝试自动查找。
	 */
	offset?: string;
	/**
	 * 要跳过多少行。如果标题下一行是描述，可以将此设置为 `1`。
	 */
	skip?: number;
	/**
	 * 对象的key在表格中的列名。如果不提供会使用第一列。
	 * 如果不存在会新建。
	 */
	key?: string;
	/**
	 * 对象从哪个模板上继承。如果不提供，或是与`key`相同则使用默认模板。
	 */
	template?: string;
	/**
	 * 是否强制创建对象。默认情况下会优先使用已有对象，保留对象已有的数据。
	 */
	overwrite?: boolean;
	/**
	 * 是否是多维表。
	 */
	multi?: boolean;
	/**
	 * 定义一个根据excel字段的生成规则
	 * @param title excel中的列标题
	 * @param field 物编中的字段
	 * @param as 数据转换器
	 */
	def<F extends EditorDataField<N>>(title: string, field: F, as?: As<EditorDataFieldType<N, F>>): void;
	/**
	 * 立即执行规则。一般来说你不需要调用，会在当前插件执行完后自动调用。
	 */
	apply(): Promise<void>;
	private getValue;
}
declare function loadFile(path: vscode.Uri | string, sheetName?: number | string): Promise<Sheet>;
declare function loadFileWithAllSheets(path: vscode.Uri | string): Promise<Sheet[]>;
declare function setBaseDir(path: vscode.Uri | string): void;
declare function rule<N extends Table$2.NameCN>(tableName: N, path: vscode.Uri | string, sheetName?: number | string): Rule<N>;
declare function init(): void;
interface UnitData {
	/**
	 * 躲避率(%)
	 *
	 * 单位躲避其他单位普通攻击的概率
	 */
	dodge_rate: number;
	/**
	 * 普攻类型
	 */
	common_atk_type: any;
	/**
	 * 模型缩放
	 *
	 * 对当前物体模型的缩放倍数，用于调整模型大小。
	 */
	body_size: number;
	/**
	 * 法术穿透
	 *
	 * 穿透敌人法术防御力。先计算固定穿透，再计算百分比穿透
	 */
	pene_mag: number;
	/**
	 * 智力
	 *
	 * 智力
	 */
	intelligence_grow: number;
	/**
	 * 小地图头像缩放
	 *
	 * 单位在小地图上的头像的缩放
	 */
	mini_map_icon_scale: number;
	/**
	 * x轴缩放
	 */
	billboard_scale_x: number;
	/**
	 * 法术穿透
	 *
	 * 穿透敌人法术防御力。先计算固定穿透，再计算百分比穿透
	 */
	pene_mag_grow: number;
	/**
	 * 默认行为
	 *
	 * 单位默认状态下会执行的行为
	 */
	default_behaviour_type: any;
	/**
	 * 头像
	 *
	 * 单位在游戏中显示的头像
	 */
	icon: any;
	/**
	 * 开启对象池
	 */
	poolable: boolean;
	/**
	 * 初始库存
	 *
	 * 单位作为商品的初始库存
	 */
	init_stock: number;
	/**
	 * 隐藏技能
	 *
	 * 隐藏技能，放在这类技能位中的技能将不会被显示在游戏中。
	 */
	passive_ability_list: any[];
	/**
	 * 转身速度
	 *
	 * 单位的转身速度
	 */
	rotate_speed: number;
	/**
	 * 敏捷
	 *
	 * 敏捷
	 */
	agility_grow: number;
	/**
	 * 商店范围
	 */
	shop_range: number;
	/**
	 * 移动类型
	 *
	 * 影响可用的可移动通道。
	 */
	move_type: any;
	/**
	 * 物理防御力
	 *
	 * 单位的物理防御力
	 */
	defense_phy_grow: number;
	/**
	 * 法术攻击力
	 *
	 * 单位的法术攻击力
	 */
	attack_mag_grow: number;
	/**
	 * 技能资源恢复
	 *
	 * 单位的每秒技能资源恢复数值
	 */
	mp_rec_grow: number;
	/**
	 * 菲涅尔指数
	 */
	fresnel_exp: number;
	/**
	 * 转向时移动速度系数
	 *
	 * 当单位转向时，移动速度会受到一定的影响。
	 */
	speed_ratio_in_turn: number;
	/**
	 * 英雄技能
	 *
	 * 单位的英雄技能，可以通过学习升级，每次学习需要消耗一个技能点（升级时获取）。在默认UI界面中，会显示在后6个技能栏内，超出的不显示但依然生效。
	 */
	hero_ability_list: any[];
	/**
	 * 暴击伤害(%)
	 *
	 * 发生暴击时，造成的暴击伤害倍数
	 */
	critical_dmg_grow: number;
	/**
	 * 头顶名称显示方式
	 *
	 * 影响游戏内物体上方的文本显示内容。
	 */
	bar_show_name: any;
	/**
	 * 生命恢复
	 *
	 * 单位的每秒生命恢复数值
	 */
	hp_rec_grow: number;
	/**
	 * 最大生命值
	 *
	 * 单位的最大生命值
	 */
	hp_max_grow: number;
	/**
	 * 单位状态
	 *
	 * 进入游戏时,为单位附加的初始状态
状态会记录层数，初始为1层。每次添加/移除状态会增加/减少一层。
	 */
	ori_bits: any;
	/**
	 * 启用圆盘阴影
	 */
	is_open_disk_shadow: boolean;
	/**
	 * 可研发科技
	 *
	 * 这些科技，可以在单位身上研发、升级。
	 */
	research_techs: any[];
	/**
	 * 开启面向移动模式
	 */
	enable_strict_facing_mode: boolean;
	/**
	 * 最大技能资源
	 *
	 * 单位的最大技能资源
	 */
	mp_max_grow: number;
	/**
	 * 主属性
	 *
	 * 英雄单位的主要属性，一般主属性的提升会对英雄有额外加成
	 */
	main_attr: any;
	/**
	 * 物理穿透
	 *
	 * 穿透敌人物理防御力。先计算固定穿透，再计算百分比穿透
	 */
	pene_phy_grow: number;
	/**
	 * 尸体消失时间
	 *
	 * 尸体消失时间
	 */
	keep_dead_body_time: number;
	/**
	 * 法术攻击力
	 *
	 * 单位的法术攻击力
	 */
	attack_mag: number;
	/**
	 * 出售列表
	 *
	 * 单位作为商店时的出售列表
	 */
	sell_list: any;
	/**
	 * 生命恢复
	 *
	 * 单位的每秒生命恢复数值
	 */
	hp_rec: number;
	/**
	 * 技能资源条颜色
	 *
	 * 该单位用来释放技能的能量的颜色
	 */
	mp_color: any;
	/**
	 * 技能资源恢复
	 *
	 * 单位的每秒技能资源恢复数值
	 */
	mp_rec: number;
	/**
	 * 求救距离
	 */
	rescue_seeker_distance: number;
	/**
	 * nil
	 */
	vision_sector_rng_grow: number;
	/**
	 * 伤害减免(%)
	 *
	 * 百分比降低受到的伤害
	 */
	dmg_reduction: number;
	/**
	 * 移动速度
	 *
	 * 单位每秒移动的距离。
	 */
	ori_speed: number;
	/**
	 * 购买开始时间
	 *
	 * 单位作为商品的可购买时间(游戏开始多久后可以购买）
	 */
	start_rft: number;
	/**
	 * 悬浮信息显示
	 *
	 * 开启后鼠标悬浮到单位身上时会显示单位名称和等级的文本框
	 */
	show_y3_extra_info: boolean;
	/**
	 * 移动速度
	 *
	 * 单位每秒移动的距离。
	 */
	ori_speed_grow: number;
	/**
	 * 特殊状态
	 *
	 * 特殊状态下会播放的动画
	 */
	special_idle_anim: string;
	/**
	 * 物理穿透(%)
	 *
	 * 百分比穿透敌人物理防御力。先计算固定穿透，再计算百分比穿透
	 */
	pene_phy_ratio: number;
	/**
	 * 防御类型
	 *
	 * 单位的护甲类型，具体效果可在游戏规则中查看
	 */
	armor_type: any;
	/**
	 * 是否在小地图显示
	 *
	 * 单位是否会在小地图上显示出来
	 */
	is_mini_map_show: boolean;
	/**
	 * 简易普攻
	 */
	simple_common_atk: any;
	/**
	 * 物理攻击力
	 *
	 * 单位的物理攻击力
	 */
	attack_phy: number;
	/**
	 * 攻击间隔
	 */
	attack_interval_grow: number;
	/**
	 * 是否预览血条
	 */
	need_preview_billboard: boolean;
	/**
	 * 被治疗效果提升(%)
	 *
	 * 提高接受治疗时受到的治疗效果
	 */
	heal_effect_grow: number;
	/**
	 * 所有伤害加成(%)
	 *
	 * 百分比提高造成的伤害
	 */
	extra_dmg: number;
	/**
	 * 警戒范围(AI)
	 *
	 * 单位的警戒范围(AI)
	 */
	alarm_range: number;
	/**
	 * 出售获得资源
	 *
	 * 单位作为商品的出售获得资源
	 */
	sell_res_list: any[];
	/**
	 * 是否开启透视
	 */
	is_open_Xray: boolean;
	/**
	 * 敏捷
	 *
	 * 敏捷
	 */
	agility: number;
	/**
	 * 小地图头像
	 *
	 * 单位在小地图上的头像
	 */
	mini_map_icon: any;
	/**
	 * y轴缩放
	 */
	billboard_scale_y: number;
	/**
	 * 物理主控行走速度
	 */
	cc_walk_speed: number;
	/**
	 * 死亡
	 *
	 * 死亡状态下会播放的动画
	 */
	die_anim: string;
	/**
	 * 标签
	 *
	 * 用于对物体的分类处理。为单位贴上标签后可以对其进行更方便的关系，例如编写游戏逻辑：杀死所有拥有XX标签的单位
	 */
	tags: any[];
	/**
	 * nil
	 */
	height_offset: number;
	/**
	 * 被治疗效果提升(%)
	 *
	 * 提高接受治疗时受到的治疗效果
	 */
	healing_effect_grow: number;
	/**
	 * 视野类型
	 *
	 * 单位与战争迷雾相关的一些属性
	 */
	view_type: any;
	/**
	 * 物理主控跳跃高度
	 */
	cc_jump_height: number;
	/**
	 * 暴击伤害(%)
	 *
	 * 发生暴击时，造成的暴击伤害倍数
	 */
	critical_dmg: number;
	/**
	 * 默认状态
	 *
	 * 默认状态下会播放的动画
	 */
	idle_anim: string;
	/**
	 * 圆盘阴影大小
	 */
	disk_shadow_size: number;
	/**
	 * 物理攻击力
	 *
	 * 单位的物理攻击力
	 */
	attack_phy_grow: number;
	/**
	 * 描述
	 *
	 * 单位的介绍说明，用在编辑器内和游戏内的Tips显示上
	 */
	description: string;
	/**
	 * 动态碰撞半径
	 */
	collision_radius_2: number;
	/**
	 * 血条样式
	 *
	 * 该单位在游戏内的血条样式
	 */
	blood_bar: any;
	/**
	 * 单位血条高度偏移
	 */
	billboard_height_offset: number;
	/**
	 * 物理
	 */
	physics_composite: any;
	/**
	 * 是否开启描边
	 */
	is_open_outline_pass: boolean;
	/**
	 * 死亡后是否销毁单位
	 *
	 * 死亡后是否会把单位完全销毁。（会在尸体消失时间结束后进行销毁，销毁后将无法再获取单位相关信息）
	 */
	destroy_after_die: boolean;
	/**
	 * 菲涅尔颜色
	 */
	fresnel_color: any;
	/**
	 * 启用菲涅尔效果
	 */
	use_fresnel: boolean;
	/**
	 * 最大技能资源
	 *
	 * 单位的最大技能资源
	 */
	mp_max: number;
	/**
	 * 法术防御力
	 *
	 * 单位的法术防御力
	 */
	defense_mag_grow: number;
	/**
	 * 物理穿透(%)
	 *
	 * 百分比穿透敌人物理防御力。先计算固定穿透，再计算百分比穿透
	 */
	pene_phy_ratio_grow: number;
	/**
	 * 是否应用玩家颜色光圈
	 */
	is_apply_role_color: boolean;
	/**
	 * 寻路碰撞额外范围
	 */
	path_finding_external_size: number;
	/**
	 * 碰撞格点
	 */
	collision_points: any;
	/**
	 * 扇形视野夜晚夹角
	 *
	 * 单位在夜晚拥有的扇形视野夹角。
	 */
	vision_sector_angle_night: number;
	/**
	 * 玩家颜色缩放
	 */
	role_color_scale: number;
	/**
	 * 单位状态列表
	 */
	state_list: any[];
	/**
	 * 使用简易小地图头像
	 *
	 * 简易小地图头像的表现为一个小点。简易小地图头像的绘制性能消耗相比普通小地图头像更小，如果地图上会出现大量的该类型单位，建议使用简易小地图头像。
	 */
	use_simple_mini_map_icon: boolean;
	/**
	 * 启用补光效果
	 */
	use_virtual_light: boolean;
	/**
	 * 攻击范围
	 */
	attack_range_grow: number;
	/**
	 * ID
	 *
	 * 单位的唯一表示
	 */
	key: number;
	/**
	 * 最大生命值
	 *
	 * 单位的最大生命值
	 */
	hp_max: number;
	/**
	 * 单位初始状态
	 */
	state_init: any;
	/**
	 * 声音事件列表
	 */
	sound_event_list: any[];
	/**
	 * 法术穿透(%)
	 *
	 * 百分比穿透敌人法术防御力。先计算固定穿透，再计算百分比穿透
	 */
	pene_mag_ratio_grow: number;
	/**
	 * nil
	 */
	is_x_offset: boolean;
	/**
	 * 出售阵营参数
	 */
	shop_camp_args: any;
	/**
	 * 玩家自定义
	 */
	kv: any;
	/**
	 * 救援类型
	 */
	rescuer_type: any;
	/**
	 * 法术吸血(%)
	 *
	 * 造成法术伤害后可以恢复自身生命值
	 */
	vampire_mag: number;
	/**
	 * nil
	 */
	width_offset: number;
	/**
	 * 物理主控跑步速度
	 */
	cc_run_speed: number;
	/**
	 * 动画状态名
	 */
	anim_state_name: string;
	/**
	 * 建造时忽略动态碰撞
	 */
	build_ignore_dyn_collision: boolean;
	/**
	 * 资源消耗
	 *
	 * 单位作为建筑时建造会消耗的资源
	 */
	build_res_cost_list: any[];
	/**
	 * 扇形视野白天夹角
	 *
	 * 单位在白天拥有的扇形视野夹角。
	 */
	vision_sector_angle_day: number;
	/**
	 * 攻击速度(%)
	 *
	 * 攻击速度(倍数)
	 */
	attack_speed_grow: number;
	/**
	 * 命中率(%)
	 *
	 * 单位普通攻击命中其他单位的概率
	 */
	hit_rate: number;
	/**
	 * 真实视野
	 *
	 * 单位所能侦测到隐身单位的范围
	 */
	vision_true: number;
	/**
	 * 是否敌友方显示不同头像
	 */
	separate_enemy_icon: boolean;
	/**
	 * 物理吸血(%)
	 *
	 * 造成物理伤害后可以恢复自身生命值
	 */
	vampire_phy_grow: number;
	/**
	 * 应用科技
	 *
	 * 单位的可应用科技（会受到该科技的影响）
	 */
	affect_techs: any[];
	/**
	 * 真实视野
	 *
	 * 单位所能侦测到隐身单位的范围
	 */
	vision_true_grow: number;
	/**
	 * 百分比生命恢复
	 *
	 * 单位的每秒生命恢复百分比数值
	 */
	hp_rec_percent: number;
	/**
	 * 出售阵营类型
	 */
	shop_sell_type: any;
	/**
	 * 物理穿透
	 *
	 * 穿透敌人物理防御力。先计算固定穿透，再计算百分比穿透
	 */
	pene_phy: number;
	/**
	 * 命中率(%)
	 *
	 * 单位普通攻击命中其他单位的概率
	 */
	hit_rate_grow: number;
	/**
	 * 商店
	 */
	shop_edit: any;
	/**
	 * 头顶名称字体
	 *
	 * 在单位头顶显示的文字字体
	 */
	billboard_name_font: any;
	/**
	 * 可移动通道
	 *
	 * 对单位移动类型的补充，决定单位究竟是在哪些通道移动。任意通道被碰撞阻挡该单位均无法通过。
	 */
	move_limitation: any;
	/**
	 * 是否做为商店
	 *
	 * 开启后单位可以作为商店编辑出售的物品
	 */
	is_shop: boolean;
	/**
	 * 悬浮信息显示内容
	 */
	y3_extra_info_show_type: any;
	/**
	 * 单位分类
	 *
	 * 单位类型决定了这类单位的一些特性，包括其可编辑的属性和某些属性的默认值。
	 */
	type: any;
	/**
	 * 是否有技能资源条
	 *
	 * 该单位是否有可以用来释放技能的能量
	 */
	has_mp: boolean;
	/**
	 * 购买所需资源
	 *
	 * 单位作为商品的购买所需资源
	 */
	buy_res_list: any[];
	/**
	 * 攻击范围
	 */
	attack_range: number;
	/**
	 * 库存恢复间隔
	 *
	 * 单位作为商品的库存恢复间隔
	 */
	refresh_interval: number;
	/**
	 * 夜晚视野
	 *
	 * 单位在夜晚可以看到（驱散战争迷雾）的范围
	 */
	vision_night: number;
	/**
	 * 物品栏
	 *
	 * 单位的物品栏格数
	 */
	bar_slot_size: number;
	/**
	 * 编辑简易普攻
	 */
	jump_to_display: any;
	/**
	 * 通用技能
	 *
	 * 单位的通用技能。在默认UI界面中，会显示在前6个技能栏内，超出的不显示但依然生效。
	 */
	common_ability_list: any[];
	/**
	 * 普通攻击
	 *
	 * 单位的普通攻击，唯一，单位对目标普通攻击时释放的技能
	 */
	common_atk: any;
	/**
	 * 允许移动的角度差
	 *
	 * 当单位转向时，如果转向角度小于该值，则会直接朝目标方向移动；反之会边转向，边移动。
	 */
	angle_tolerance: number;
	/**
	 * 编辑器后缀
	 *
	 * 给使用编辑器的用户看的备注，无实际作用
	 */
	suffix: string;
	/**
	 * 静态碰撞跟随面向
	 *
	 * 仅对建筑类型单位生效。勾选时，单位改变朝向时会使静态碰撞跟随旋转。
	 */
	collision_box_turning_enable: boolean;
	/**
	 * 移动类型
	 *
	 * 单位的移动类型，决定单位究竟是在地面移动还是在空中移动。
	 */
	move_channel: any;
	/**
	 * 掉落物品
	 *
	 * 单位死亡后会掉落的物品
	 */
	drop_items_tuple: any[];
	/**
	 * 是否显示血条刻度
	 *
	 * 单位血条上是否会出现刻度线
	 */
	bar_show_scale: boolean;
	/**
	 * 攻击类型
	 *
	 * 单位的攻击类型，具体效果可在游戏规则中查看
	 */
	attack_type: any;
	/**
	 * 求救类型
	 */
	rescue_seeker_type: any;
	/**
	 * 取消警戒范围(AI)
	 *
	 * 单位的取消警戒范围(AI)，敌方离开取消警戒范围后会不再主动攻击敌方
	 */
	cancel_alarm_range: number;
	/**
	 * 背包栏
	 *
	 * 单位的背包栏格数
	 */
	pkg_slot_size: number;
	/**
	 * 法术防御力
	 *
	 * 单位的法术防御力
	 */
	defense_mag: number;
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 防御塔仇恨持续时间
	 */
	tower_hatred_duration: number;
	/**
	 * 开启物品背包栏
	 */
	enable_item_slots: boolean;
	/**
	 * 所有伤害加成(%)
	 *
	 * 百分比提高造成的伤害
	 */
	extra_dmg_grow: number;
	/**
	 * 暴击率(%)
	 *
	 * 单位普通攻击有概率造成额外伤害
	 */
	critical_chance: number;
	/**
	 * 经验
	 *
	 * 单位被敌方击杀后，敌方可获得的经验
	 */
	reward_exp: number;
	/**
	 * 预览血量
	 */
	preview_billboard_health_value: number;
	/**
	 * 最大平衡角度
	 */
	max_balance_angle: number;
	/**
	 * 离地高度
	 *
	 * 单位的离地高度
	 */
	model_height: number;
	/**
	 * 救援后返回
	 */
	rescue_finish_return: boolean;
	/**
	 * 百分比生命恢复
	 *
	 * 单位的每秒生命恢复百分比数值
	 */
	hp_rec_percent_grow: number;
	/**
	 * 移动动画播放速率系数
	 *
	 * 单位移动时动画的播放速度
	 */
	standard_walk_rate: number;
	/**
	 * nil
	 */
	vision_sector_angle_night_grow: number;
	/**
	 * 前置条件
	 *
	 * 训练、购买、建造该单位的前置条件
	 */
	precondition_list: any[];
	/**
	 * 白天视野
	 *
	 * 单位在白天可以看到（驱散战争迷雾）的范围
	 */
	vision_rng_grow: number;
	/**
	 * 攻击间隔
	 */
	attack_interval: number;
	/**
	 * 描边色值（RGB）
	 */
	outline_pass_color: any;
	/**
	 * nil
	 */
	vision_sector_angle_day_grow: number;
	/**
	 * 力量
	 *
	 * 力量
	 */
	strength: number;
	/**
	 * nil
	 */
	vision_sector_night_grow: number;
	/**
	 * 夜晚视野
	 *
	 * 单位在夜晚可以看到（驱散战争迷雾）的范围
	 */
	vision_night_grow: number;
	/**
	 * 白天视野
	 *
	 * 单位在白天可以看到（驱散战争迷雾）的范围
	 */
	vision_rng: number;
	/**
	 * 寻路碰撞网格边长
	 *
	 * 碰撞动态半径，每50为1个标准格。
	 */
	dynamic_collision_r: number;
	/**
	 * 暴击率(%)
	 *
	 * 单位普通攻击有概率造成额外伤害
	 */
	critical_chance_grow: number;
	/**
	 * nil
	 */
	is_z_offset: boolean;
	/**
	 * 菲涅尔强度
	 */
	fresnel_emissive_color_strength: number;
	/**
	 * 冷却缩减(%)
	 *
	 * 单位技能进入cd时减少部分冷却时间
	 */
	cd_reduce_grow: number;
	/**
	 * 物理防御力
	 *
	 * 单位的物理防御力
	 */
	defense_phy: number;
	/**
	 * 等级
	 *
	 * 单位的默认等级
	 */
	level: number;
	/**
	 * 血条显示模式
	 *
	 * 该单位在游戏内的血条的显示时机
	 */
	blood_show_type: any;
	/**
	 * 模型不透明度
	 */
	model_opacity: number;
	/**
	 * 基础材质变色
	 */
	base_tint_color: any;
	/**
	 * 强制显示在小地图
	 *
	 * 勾选后单位将强制显示在小地图上，无视战争阴影
	 */
	force_show_on_mini_map: boolean;
	/**
	 * 材质颜色叠加类型
	 */
	base_color_mod: any;
	/**
	 * 被治疗效果加成(%)
	 *
	 * 提高接受治疗时受到的治疗效果
	 */
	heal_effect: number;
	/**
	 * 建造时间（秒）
	 */
	build_time: number;
	/**
	 * 伤害减免(%)
	 *
	 * 百分比降低受到的伤害
	 */
	dmg_reduction_grow: number;
	/**
	 * 技能资源名称
	 *
	 * 该单位用来释放技能的能量的名称
	 */
	mp_key: string;
	/**
	 * 冷却缩减(%)
	 *
	 * 单位技能进入cd时减少部分冷却时间
	 */
	cd_reduce: number;
	/**
	 * 无法移动时仍然保持目标
	 *
	 * 该字段未勾选时，在目标移动出自身的警戒范围后，且自身不能移动时，会立即开始寻找一个新的攻击目标。多用于定点守卫。
	 */
	keep_target: boolean;
	/**
	 * 名称
	 *
	 * 当前单位的名称
	 */
	name: string;
	/**
	 * 无法反击时会逃跑
	 *
	 * 当单位受到伤害且自身无法反击时，会向伤害来源的相反方向移动一段距离，仅在警戒状态下生效
	 */
	can_flee: boolean;
	/**
	 * 物理主控加速速率
	 */
	cc_move_acc_rate: number;
	/**
	 * 物理主控加速度
	 */
	cc_move_acc: number;
	/**
	 * 行走
	 *
	 * 行走状态下会播放的动作
	 */
	walk_anim: string;
	/**
	 * 描边厚度
	 */
	outline_pass_width: number;
	/**
	 * 求救间隔
	 */
	rescue_seeker_interval: number;
	/**
	 * 敌方小地图头像
	 */
	enemy_mini_map_icon: any;
	/**
	 * 力量
	 *
	 * 力量
	 */
	strength_grow: number;
	/**
	 * 物理吸血(%)
	 *
	 * 造成物理伤害后可以恢复自身生命值
	 */
	vampire_phy: number;
	/**
	 * 攻击速度(%)
	 *
	 * 单位的攻击速度百分比，局内显示的实际攻速为:1/单位当前普通攻击技能冷却时间*攻击速度
	 */
	attack_speed: number;
	/**
	 * 扇形视野夜晚半径
	 *
	 * 单位在夜晚拥有的扇形视野半径。
	 */
	vision_sector_night: number;
	/**
	 * 被治疗效果加成(%)
	 *
	 * 提高接受治疗时受到的治疗效果
	 */
	healing_effect: number;
	/**
	 * 模型
	 *
	 * 当前单位所使用的的模型
	 */
	model: any;
	/**
	 * 智力
	 *
	 * 智力
	 */
	intelligence: number;
	/**
	 * 法术吸血(%)
	 *
	 * 造成法术伤害后可以恢复自身生命值
	 */
	vampire_mag_grow: number;
	/**
	 * 最大库存
	 *
	 * 单位作为商品的最大库存
	 */
	max_stock: number;
	/**
	 * 扇形视野白天半径
	 *
	 * 单位在白天拥有的扇形视野半径。
	 */
	vision_sector_rng: number;
	/**
	 * 允许反击范围
	 */
	counterattack_range: number;
	/**
	 * 躲避率(%)
	 *
	 * 单位躲避其他单位普通攻击的概率
	 */
	dodge_rate_grow: number;
	/**
	 * 是否启用基础材质变色
	 */
	use_base_tint_color: boolean;
	/**
	 * 升级列表
	 */
	build_upgrade_list: any[];
	/**
	 * 法术穿透(%)
	 *
	 * 百分比穿透敌人法术防御力。先计算固定穿透，再计算百分比穿透
	 */
	pene_mag_ratio: number;
}
interface SoundData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 音量
	 */
	volume: number;
	/**
	 * 描述
	 */
	description: string;
	/**
	 * 2D声音
	 */
	sound_id: any;
	/**
	 * 最小距离
	 */
	min_dist: number;
	/**
	 * 淡出时间
	 */
	fade_out_time: number;
	/**
	 * 播放速度
	 */
	speed: number;
	/**
	 * 最大距离
	 */
	max_dist: number;
	/**
	 * 总时间
	 */
	total_time: number;
	/**
	 * 标签
	 */
	tags: any[];
	/**
	 * 图标
	 */
	icon: any;
	/**
	 * 2D声音
	 */
	sound_id_list: any[];
	/**
	 * 编辑器后缀
	 */
	suffix: string;
	/**
	 * 分组
	 */
	group: number;
	/**
	 * 玩家自定义
	 */
	kv: any;
	/**
	 * 名称
	 */
	name: string;
	/**
	 * 优先级
	 */
	priority: number;
	/**
	 * 类型
	 */
	type: number;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 淡入时间
	 */
	fade_in_time: number;
}
interface AbilityData {
	/**
	 * 技能阶段配置
	 */
	ability_stage_config: any;
	/**
	 * 物品
	 */
	type_priority_item: number;
	/**
	 * 施法开始可以被打断
	 */
	can_ps_interrupt: boolean;
	/**
	 * 阵营
	 */
	filter_condition_camp: any;
	/**
	 * 敌人
	 */
	camp_priority_enemy: number;
	/**
	 * 可破坏物
	 */
	type_priority_destructible: number;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 近战
	 */
	is_meele: boolean;
	/**
	 * 准备特效
	 */
	sp_sfx_list: any[];
	/**
	 * 施法完成可以被打断
	 */
	can_bs_interrupt: boolean;
	/**
	 * 连续施法
	 */
	collection_continuously: boolean;
	/**
	 * 立刻施法
	 */
	is_immediate: any;
	/**
	 * 宽度
	 */
	arrow_width: string[];
	/**
	 * 长度
	 */
	arrow_length: string[];
	/**
	 * 消耗生命是否致死
	 */
	cost_hp_can_die: boolean;
	/**
	 * 生命值消耗
	 */
	ability_hp_cost: string[];
	/**
	 * 魔法书技能
	 */
	magicbook_list: any[];
	/**
	 * 受击特效
	 */
	hit_sfx_list: any[];
	/**
	 * 施法引导
	 */
	ability_prepare_time: number;
	/**
	 * 单位移动类型
	 */
	filter_condition_move_channel_type: any;
	/**
	 * 前摇特效
	 */
	ps_sfx_list: any[];
	/**
	 * 攻击范围预览特效
	 */
	building_attack_range_sfx: any;
	/**
	 * 可破坏物标签要求
	 */
	collection_destructible_tags: any;
	/**
	 * 编辑器后缀
	 */
	suffix: string;
	/**
	 * 声音事件列表
	 */
	sound_event_list: any[];
	/**
	 * 玩家自定义
	 */
	kv: any;
	/**
	 * 移动会对技能产生影响
	 */
	influenced_by_move: boolean;
	/**
	 * 生命不足能否施放
	 */
	can_cast_when_hp_insufficient: boolean;
	/**
	 * 自动拾取
	 */
	auto_pick: boolean;
	/**
	 * 英雄
	 */
	type_priority_hero: number;
	/**
	 * 施法开始
	 */
	ability_cast_point: number;
	/**
	 * 消耗生命值施放
	 */
	can_cost_hp: boolean;
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 施法引导可以被打断
	 */
	can_prepare_interrupt: boolean;
	/**
	 * 玩家属性消耗
	 */
	player_props_cost: any[];
	/**
	 * 前置条件
	 *
	 * 训练、购买、建造该单位的前置条件
	 */
	precondition_list: any[];
	/**
	 * 采集动画
	 */
	collection_animation: string;
	/**
	 * 技能消耗
	 */
	ability_cost: string[];
	/**
	 * 击中音效
	 */
	hit_sound_effect: any[];
	/**
	 * 结束音效
	 */
	end_sound_effect: any[];
	/**
	 * 技能释放类型
	 */
	ability_cast_type: any;
	/**
	 * 自动施法
	 */
	is_autocast: boolean;
	/**
	 * 充能时间
	 */
	ability_stack_cd: string[];
	/**
	 * 建筑
	 */
	type_priority_building: number;
	/**
	 * 施法打断范围
	 */
	ability_break_cast_range: string[];
	/**
	 * 生物
	 */
	type_priority_creature: number;
	/**
	 * 可以超出范围施法
	 */
	release_immediately_out_of_range: boolean;
	/**
	 * 技能伤害值
	 */
	ability_damage: string[];
	/**
	 * 攻击范围预览
	 */
	show_building_attack_range: boolean;
	/**
	 * 是否转身
	 */
	need_turn_to_target: boolean;
	/**
	 * 前摇音效
	 */
	ps_sound_effect: any[];
	/**
	 * 角度
	 */
	sector_angle: string[];
	/**
	 * 显示准备倒计时
	 */
	sp_count_down: boolean;
	/**
	 * 冷却时间
	 */
	cold_down_time: string[];
	/**
	 * 圆形半径
	 */
	circle_radius: string[];
	/**
	 * 是否为蓄力技能
	 */
	is_charge_ability: boolean;
	/**
	 * 建造单位
	 */
	build_list: any[];
	/**
	 * 结束特效
	 */
	end_sfx_list: any[];
	/**
	 * 后摇特效
	 */
	bs_sfx_list: any[];
	/**
	 * 名称
	 */
	name: string;
	/**
	 * 循环播放动画
	 */
	collection_animation_loop: boolean;
	/**
	 * 建造角度
	 */
	build_rotate: number;
	/**
	 * 己方
	 */
	camp_priority_self: number;
	/**
	 * 建造方式
	 */
	ability_build_subtype: any;
	/**
	 * 特殊筛选
	 */
	target_attribute: any;
	/**
	 * 攻击命令触发自动施法
	 */
	can_autocast_when_attack_target: boolean;
	/**
	 * 扇形半径
	 */
	sector_radius: string[];
	/**
	 * 物品标签要求
	 */
	filter_item_tags: any;
	/**
	 * 描述
	 */
	description: string;
	/**
	 * 单位排除标签
	 */
	forbid_unit_tags: any;
	/**
	 * 单位标签要求
	 */
	filter_unit_tags: any;
	/**
	 * 准备音效
	 */
	sp_sound_effect: any[];
	/**
	 * 施法特效
	 */
	cst_sfx_list: any[];
	/**
	 * 图标
	 */
	ability_icon: any;
	/**
	 * 施法音效
	 */
	cst_sound_effect: any[];
	/**
	 * 技能受冷却影响
	 */
	influenced_by_cd_reduce: boolean;
	/**
	 * 类型
	 */
	filter_condition_type: any;
	/**
	 * 标签
	 */
	tags: any[];
	/**
	 * 释放范围
	 */
	ability_cast_range: string[];
	/**
	 * 可以缓存
	 */
	can_cache: boolean;
	/**
	 * 中立
	 */
	camp_priority_neutral: number;
	/**
	 * 指示器类型
	 */
	sight_type: any;
	/**
	 * 技能绑定动画轨
	 */
	ability_timeline_resource: any;
	/**
	 * 允许学习等级
	 */
	required_level: any;
	/**
	 * 技能影响范围
	 */
	ability_damage_range: string[];
	/**
	 * 最大充能数
	 */
	ability_max_stack_count: string[];
	/**
	 * 采集获得量
	 */
	pick_count: number;
	/**
	 * 技能可以打断其他技能
	 */
	can_interrupt_others: boolean;
	/**
	 * 施法出手
	 */
	ability_channel_time: number;
	/**
	 * 施法完成
	 */
	ability_bw_point: number;
	/**
	 * 技能最大等级
	 */
	ability_max_level: number;
	/**
	 * 施法出手可以被打断
	 */
	can_cast_interrupt: boolean;
	/**
	 * 队友
	 */
	camp_priority_friend: number;
	/**
	 * 编辑技能效果
	 */
	art_resource_btn: any;
	/**
	 * 后摇音效
	 */
	bs_sound_effect: any[];
}
interface DecorationData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 材质变色强度
	 */
	material_color_intensity: number;
	/**
	 * 高度图
	 */
	collision_height: any;
	/**
	 * 启用补光效果
	 */
	use_virtual_light: boolean;
	/**
	 * 模型
	 */
	model: any;
	/**
	 * 暂未配置55
	 */
	icon: any;
	/**
	 * 效果编辑按钮
	 */
	effect_button: any;
	/**
	 * 挂接物列表
	 */
	attach_models: any;
	/**
	 * 接收贴花
	 */
	receive_decal: boolean;
	/**
	 * 启用菲涅尔效果
	 */
	use_fresnel: boolean;
	/**
	 * 碰撞盒
	 */
	collision_box: any;
	/**
	 * 材质颜色叠加类型
	 */
	base_color_mod: any;
	/**
	 * 不透明度
	 */
	material_alpha: number;
	/**
	 * 菲涅尔指数
	 */
	fresnel_exp: number;
	/**
	 * 菲涅尔强度
	 */
	fresnel_emissive_color_strength: number;
	/**
	 * 名称
	 */
	name: string;
	/**
	 * 菲涅尔颜色
	 */
	fresnel_color: any;
	/**
	 * 是否产生阴影
	 */
	cast_shadow: boolean;
	/**
	 * nil
	 */
	enable_camera_collision: boolean;
	/**
	 * 可通行
	 */
	use_physics: boolean;
	/**
	 * 遮挡透视
	 */
	enable_occlusion_perspective: boolean;
	/**
	 * 碰撞格点
	 */
	collision_points: any;
	/**
	 * 基础材质变色
	 */
	base_tint_color: any;
	/**
	 * 基础材质变色
	 */
	material_color: any;
	/**
	 * 编辑器后缀
	 */
	suffix: string;
	/**
	 * 模型不透明度
	 */
	model_opacity: number;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 缩放
	 */
	scale: number;
	/**
	 * 玩家自定义
	 */
	kv: any;
	/**
	 * 获得特效列表
	 */
	effect_list: any;
	/**
	 * 是否启用基础材质变色
	 */
	use_base_tint_color: boolean;
	/**
	 * 材质变化
	 */
	material_change: any;
	/**
	 * 描述
	 */
	description: string;
}
interface DestructibleData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 小地图 - 显示
	 */
	show_on_mini_map: boolean;
	/**
	 * 资源名称
	 */
	source_desc: string;
	/**
	 * 模型缩放
	 *
	 * 对当前物体模型的缩放倍数，用于调整模型大小。
	 */
	body_size: number;
	/**
	 * 可被攻击
	 */
	is_attacked: boolean;
	/**
	 * 死亡时销毁
	 */
	destroy_on_die: boolean;
	/**
	 * 玩家属性资源
	 */
	source_player_prop: any;
	/**
	 * 启用补光效果
	 */
	use_virtual_light: boolean;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 生命值
	 */
	hp_max: number;
	/**
	 * 图标
	 */
	icon: any;
	/**
	 * 资源初始数量
	 */
	source_nums_init: number;
	/**
	 * 持续特效列表
	 */
	effect_list: any;
	/**
	 * 声音事件列表
	 */
	sound_event_list: any[];
	/**
	 * 接收贴花
	 */
	receive_decal: boolean;
	/**
	 * 菲涅尔强度
	 */
	fresnel_emissive_color_strength: number;
	/**
	 * 资源类型
	 */
	source_type: any;
	/**
	 * 是否可通行
	 */
	passable: boolean;
	/**
	 * nil
	 */
	dead_height_box_data: string;
	/**
	 * 资源回复间隔
	 */
	source_refresh_interval: number;
	/**
	 * 遮挡透视
	 */
	enable_occlusion_perspective: boolean;
	/**
	 * 启用菲涅尔效果
	 */
	use_fresnel: boolean;
	/**
	 * 材质颜色叠加类型
	 */
	base_color_mod: any;
	/**
	 * 玩家自定义
	 */
	kv: any;
	/**
	 * 死亡特效列表
	 */
	die_effect_list: any;
	/**
	 * 描述
	 */
	description: string;
	/**
	 * 不透明度
	 */
	material_alpha: number;
	/**
	 * 菲涅尔指数
	 */
	fresnel_exp: number;
	/**
	 * 基础材质变色
	 */
	base_tint_color: any;
	/**
	 * 物品类型
	 */
	source_item: any;
	/**
	 * 小地图 - 颜色
	 */
	mini_map_color: any;
	/**
	 * 可被采集
	 */
	is_collected: boolean;
	/**
	 * 材质变色强度
	 */
	material_color_intensity: number;
	/**
	 * 基础材质变色
	 */
	material_color: any;
	/**
	 * 物品标签
	 *
	 * 用于对物体的分类处理。为单位贴上标签后可以对其进行更方便的关系，例如编写游戏逻辑：杀死所有拥有XX标签的单位
	 */
	tags: any[];
	/**
	 * 菲涅尔颜色
	 */
	fresnel_color: any;
	/**
	 * 可被选中
	 */
	is_selected: boolean;
	/**
	 * 默认角度
	 */
	collision_points_dead: any;
	/**
	 * 可被作为技能目标
	 */
	is_ability_target: boolean;
	/**
	 * 资源回复数量
	 */
	source_refresh_count: number;
	/**
	 * 模型
	 */
	model: any;
	/**
	 * 默认角度
	 */
	collision_points_alive: any;
	/**
	 * 资源最大数量
	 */
	source_nums_max: number;
	/**
	 * 编辑器后缀
	 */
	suffix: string;
	/**
	 * 模型不透明度
	 */
	model_opacity: number;
	/**
	 * 死亡销毁延迟
	 */
	destroy_delay: number;
	/**
	 * 名称
	 */
	name: string;
	/**
	 * 资源耗尽时死亡
	 */
	die_on_source_run_out: boolean;
	/**
	 * nil
	 */
	alive_height_box_data: string;
	/**
	 * 是否启用基础材质变色
	 */
	use_base_tint_color: boolean;
	/**
	 * 材质变化
	 */
	material_change: any;
	/**
	 * 默认角度
	 */
	collision_box: any;
}
interface ItemData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 未拾取时间到期消失
	 */
	delete_on_discard: boolean;
	/**
	 * 可以遗弃
	 *
	 * 玩家是否可以将物品丢弃到地面
	 */
	discard_enable: boolean;
	/**
	 * 合成素材
	 *
	 * 合成这件物品所需要的材料，拥有所有合成原料后会自动合成该物品
	 */
	compose_list: any[];
	/**
	 * 启用补光效果
	 */
	use_virtual_light: boolean;
	/**
	 * ID
	 *
	 * 物品的ID
	 */
	key: number;
	/**
	 * 购买开始时间
	 *
	 * 游戏开始后多长时间才能购买该类物品
	 */
	start_rft: number;
	/**
	 * 前置条件
	 *
	 * 训练、购买、建造该单位的前置条件
	 */
	precondition_list: any[];
	/**
	 * 图标
	 *
	 * 物品的头像
	 */
	icon: any;
	/**
	 * 开启碰撞
	 */
	disable_overlapping: boolean;
	/**
	 * 初始库存
	 *
	 * 物品作为商品时在商店中的初始可购买数
	 */
	init_stock: number;
	/**
	 * 特效列表
	 */
	effect_list: any;
	/**
	 * 声音事件列表
	 */
	sound_event_list: any[];
	/**
	 * 堆叠类型
	 *
	 * 物品的堆叠或者充能逻辑。
	 */
	stack_type: any;
	/**
	 * 库存恢复间隔
	 *
	 * 当前物品作为商品时，商店库存增加的间隔时间
	 */
	refresh_interval: number;
	/**
	 * 主动技能
	 *
	 * 使用该物品的时释放的主动技能
	 */
	attached_ability: any;
	/**
	 * 启用菲涅尔效果
	 */
	use_fresnel: boolean;
	/**
	 * 消失时间
	 *
	 * 掉落在地面上的消失时间
	 */
	drop_stay_time: number;
	/**
	 * 菲涅尔强度
	 */
	fresnel_emissive_color_strength: number;
	/**
	 * 被动技能
	 */
	attached_passive_abilities: any[];
	/**
	 * 描述
	 *
	 * 物品的描述和介绍
	 */
	description: string;
	/**
	 * 菲涅尔颜色
	 */
	fresnel_color: any;
	/**
	 * 持有者死亡时掉落
	 *
	 * 物品是否会在携带者死亡时掉落地面
	 */
	discard_when_dead: boolean;
	/**
	 * 不透明度
	 */
	material_alpha: number;
	/**
	 * 材质变色强度
	 */
	material_color_intensity: number;
	/**
	 * 自动使用
	 *
	 * 勾选后获得该物品时会自动使用该物品，如果不满足该物品的主动技能消耗条件则无法拾取
	 */
	auto_use: boolean;
	/**
	 * 名称显示方式
	 */
	item_billboard_type: any;
	/**
	 * 菲涅尔指数
	 */
	fresnel_exp: number;
	/**
	 * 模型
	 *
	 * 物品掉落在地面的模型
	 */
	model: any;
	/**
	 * 等级
	 *
	 * 物品的等级
	 */
	level: number;
	/**
	 * 基础材质变色
	 */
	base_tint_color: any;
	/**
	 * CD组
	 *
	 * 该物品所在的CD组，物品使用时会使单位持有的相同CD组内所有物品进入使用物品的主动技能冷却
	 */
	cd_type: string;
	/**
	 * 材质颜色叠加类型
	 */
	base_color_mod: any;
	/**
	 * 生命值
	 *
	 * 物品的生命值，生命值归零则会被销毁
	 */
	hp_max: number;
	/**
	 * 使用消耗次数
	 *
	 * 物品是堆叠类型时，每次使用该物品消耗的堆叠层数
	 */
	use_consume: number;
	/**
	 * 最大充能数
	 *
	 * 物品可以设置的最大充能层数
	 */
	maximum_charging: number;
	/**
	 * 玩家自定义
	 */
	kv: any;
	/**
	 * 出售获得资源
	 *
	 * 出售到商店时获得的资源
	 */
	sell_res_list: any[];
	/**
	 * 购买所需资源
	 *
	 * 从商店里购买这件物品所需要的资源
	 */
	buy_res_list: any[];
	/**
	 * 可以被抵押
	 *
	 * 是否可以将该物品出售到商店
	 */
	sale_enable: boolean;
	/**
	 * 物品标签
	 *
	 * 用于对物体的分类处理。为单位贴上标签后可以对其进行更方便的关系，例如编写游戏逻辑：杀死所有拥有XX标签的单位
	 */
	tags: any[];
	/**
	 * 默认堆叠数
	 */
	cur_stack: number;
	/**
	 * 材质变化颜色
	 */
	material_color: any;
	/**
	 * 最大堆叠
	 *
	 * 物品可以叠加的最大堆叠层数。重复获得物品时，在不大于该值的情况下物品会自动堆叠。
	 */
	maximum_stacking: number;
	/**
	 * 模型不透明度
	 */
	model_opacity: number;
	/**
	 * 最大库存
	 *
	 * 物品作为商品时在商店中的最大可购买数
	 */
	max_stock: number;
	/**
	 * 编辑器后缀
	 *
	 * 在编辑器下显示在名字后面的后缀，在游戏内不显示
	 */
	suffix: string;
	/**
	 * 名称
	 */
	name: string;
	/**
	 * 默认充能数
	 */
	cur_charge: number;
	/**
	 * 是否启用基础材质变色
	 */
	use_base_tint_color: boolean;
	/**
	 * 材质变化
	 */
	material_change: any;
	/**
	 * 尺寸
	 *
	 * 物品模型的缩放比例
	 */
	body_size: number;
}
interface ModifierData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 是否影响自己
	 */
	is_influence_self: boolean;
	/**
	 * 材质变色强度
	 */
	material_color_intensity: number;
	/**
	 * 最大持续时间
	 */
	get_effect_list: any;
	/**
	 * 最大持续时间
	 */
	attach_model_list: any;
	/**
	 * 同源覆盖
	 */
	same_origin_cover: boolean;
	/**
	 * 不影响单位标签
	 */
	ign_inf_unit_tag: any[];
	/**
	 * 护盾类型
	 */
	shield_type: any;
	/**
	 * 目标允许
	 */
	target_allow: any;
	/**
	 * 图标
	 */
	modifier_icon: any;
	/**
	 * 最大持续时间
	 */
	lose_effect_list: any;
	/**
	 * 声音事件列表
	 */
	sound_event_list: any[];
	/**
	 * 效果影响
	 */
	modifier_effect: any;
	/**
	 * 覆盖护盾变化
	 */
	shield_change_of_cover: any;
	/**
	 * 影响单位标签
	 */
	inf_unit_tag: any[];
	/**
	 * 描述
	 */
	description: string;
	/**
	 * 覆盖类型
	 */
	modifier_cover_type: any;
	/**
	 * 覆盖层数变化
	 */
	layer_change_of_cover: any;
	/**
	 * 标签
	 */
	tags: any[];
	/**
	 * 不透明度
	 */
	material_alpha: number;
	/**
	 * 基础材质变色
	 */
	material_color: any;
	/**
	 * 层数上限
	 */
	layer_max: number;
	/**
	 * 效果类别
	 */
	modifier_type: any;
	/**
	 * 循环周期
	 */
	cycle_time: number;
	/**
	 * 不影响单位类型
	 */
	ign_inf_unit_type: any;
	/**
	 * 名称
	 */
	name: string;
	/**
	 * 是否死亡时消失
	 */
	disappear_when_dead: boolean;
	/**
	 * 编辑器后缀
	 */
	suffix: string;
	/**
	 * 光环效果
	 */
	halo_effect: any;
	/**
	 * 影响范围
	 */
	influence_rng: number;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 玩家自定义
	 */
	kv: any;
	/**
	 * 覆盖时间变化
	 */
	time_change_of_cover: any;
	/**
	 * 显示图标
	 */
	show_on_ui: boolean;
	/**
	 * 材质变化
	 */
	material_change: any;
	/**
	 * 护盾值
	 */
	shield_value: number;
}
interface ProjectileData {
	/**
	 * 字符串ID
	 */
	uid: string;
	/**
	 * 描述
	 */
	description: string;
	/**
	 * 敌方特效
	 */
	effect_foes: any;
	/**
	 * 可移动通道
	 *
	 * 对单位移动类型的补充，决定单位究竟是在哪些通道移动。任意通道被碰撞阻挡该单位均无法通过。
	 */
	move_limitation: any;
	/**
	 * ID
	 */
	key: number;
	/**
	 * 标签
	 */
	tags: any[];
	/**
	 * 是否循环播放
	 */
	sfx_loop: boolean;
	/**
	 * 图标
	 */
	icon: any;
	/**
	 * 开启对象池
	 */
	poolable: boolean;
	/**
	 * 是否立即移除表现
	 */
	effect_destroy_way_is_immediately: boolean;
	/**
	 * 声音事件列表
	 */
	sound_event_list: any[];
	/**
	 * 移动类型
	 *
	 * 单位的移动类型，决定单位究竟是在地面移动还是在空中移动。
	 */
	move_channel: any;
	/**
	 * 最大持续时间
	 */
	max_duration: number;
	/**
	 * 玩家自定义
	 */
	kv: any;
	/**
	 * 名称
	 */
	name: string;
	/**
	 * 特效配置
	 */
	effect_friend: any;
	/**
	 * 编辑器后缀
	 */
	suffix: string;
	/**
	 * 区分敌我特效显示
	 */
	async_effect: boolean;
}
interface TechData {
	/**
	 * UID
	 */
	uid: string;
	/**
	 * 影响单位标签
	 */
	affect_tags: any[];
	/**
	 * 描述信息
	 */
	description: string;
	/**
	 * 编辑器后缀
	 *
	 * 在编辑器下显示在名字后面的后缀，在游戏内不显示
	 */
	suffix: string;
	/**
	 * 玩家自定义
	 */
	kv: any;
	/**
	 * 影响全部单位
	 */
	affect_all: boolean;
	/**
	 * 名称
	 */
	name: string;
	/**
	 * ID
	 *
	 * 单位的唯一表示
	 */
	key: number;
	/**
	 * 应用科技
	 */
	cells: any;
	/**
	 * 标签
	 */
	tags: any[];
	/**
	 * 最大等级
	 */
	max_lv: number;
}

interface MapSound {
}
interface MapAbility {
}
interface MapDecoration {
}
interface MapDestructible {
}
interface MapItem {
}
interface MapModifier {
}
interface MapProjectile {
}
interface MapTech {
}
type KV = Record<string, string | number | boolean>;
interface CommonPatch {
	/**
	 * 存放自定义的键值对。新增值只能为字符串、数字或布尔值。
	 */
	kv: KV;
}
type Data<T> = T & CommonPatch;
type EditorData<N extends Table$2.NameCN> = N extends "\u5355\u4F4D" ? Data<UnitData> & MapUnit : N extends "\u58F0\u97F3" ? Data<SoundData> & MapSound : N extends "\u6280\u80FD" ? Data<AbilityData> & MapAbility : N extends "\u88C5\u9970\u7269" ? Data<DecorationData> & MapDecoration : N extends "\u53EF\u7834\u574F\u7269" ? Data<DestructibleData> & MapDestructible : N extends "\u7269\u54C1" ? Data<ItemData> & MapItem : N extends "\u9B54\u6CD5\u6548\u679C" ? Data<ModifierData> & MapModifier : N extends "\u6295\u5C04\u7269" ? Data<ProjectileData> & MapProjectile : N extends "\u79D1\u6280" ? Data<TechData> & MapTech : never;
type ItemShape = string | boolean | number | bigint | null | TupleShape | MapShape | ArrayShape;
type ArrayShape = ItemShape[];
type TupleShape = {
	__tuple__: true;
	items: ItemShape[];
};
type MapShape = {
	[key: string]: any;
};
declare class FieldInfo {
	tableName: Table$2.NameCN;
	field: string;
	desc?: string;
	tips?: string;
	type?: string;
	constructor(tableName: Table$2.NameCN, field: string);
}
declare function ready(): Promise<void>;
declare class EditorObject<N extends Table$2.NameCN = Table$2.NameCN> {
	private manager;
	tableName: N;
	key: number;
	private _json?;
	private _name?;
	private _text?;
	uri?: vscode.Uri;
	constructor(manager: EditorManager, tableName: N, key: number);
	toString(): string;
	/**
	 * 获取对象的json数据语法树
	 */
	get json(): y3.json.Json | undefined;
	get text(): string | undefined;
	set text(text: string);
	/**
	 * 获取对象的物编数据
	 */
	private _data?;
	get data(): EditorData<N>;
	private get;
	set(key: string, value: ItemShape, convertType?: boolean): boolean;
	private rawGet;
	private rawSet;
	/**
	 * 获取对象的名称
	 */
	get name(): string;
	private updateFile;
	getFieldInfo(field: string): y3.table.FieldInfo;
	private _fieldList?;
	listFields(): string[];
	private serialize;
	private deserialize;
	flushName(): void;
}
interface CreateOptions<N extends Table$2.NameCN> {
	/**
	 * 新对象的名称，如果不填则使用默认名称
	 */
	name?: string;
	/**
	 * 新对象的key，如果不填则自动生成
	 */
	key?: number;
	/**
	 * 从哪个对象复制，如果不填则从模板复制为空对象
	 */
	copyFrom?: number | EditorObject<N>;
	/**
	 * 如果目标key已存在，是否覆盖
	 */
	overwrite?: boolean;
}
declare class EditorTable<N extends Table$2.NameCN = Table$2.NameCN> extends vscode.Disposable {
	private manager;
	name: N;
	uri: vscode.Uri;
	nameEN: {
		readonly 单位: "unit";
		readonly 装饰物: "decoration";
		readonly 物品: "item";
		readonly 技能: "ability";
		readonly 魔法效果: "modifier";
		readonly 投射物: "projectile";
		readonly 科技: "technology";
		readonly 可破坏物: "destructible";
		readonly 声音: "sound";
	}[N];
	private _objectCache;
	private watcher?;
	constructor(manager: EditorManager, name: N);
	toString(): string;
	/**
	 * 获取具体的对象
	 * @param key 对象的key（一串数字）
	 * @returns 对象
	 */
	get(key: number): Promise<EditorObject<N> | undefined>;
	fetch(key: number): EditorObject<N> | undefined;
	private _listCache?;
	/**
	 * 获取这个类型下的所有对象的key
	 * @returns 这个类型下的所有对象的key
	 */
	getList(): Promise<number[]>;
	fetchList(): number[] | undefined;
	/**
	 * 删除一个对象
	 * @param key 对象的key
	 */
	delete(key: number): Promise<void>;
	/**
	 * 检查一个key是否可以使用
	 * @param key 要检查的key
	 * @param overwirte 是否允许覆盖已有的key，默认不允许
	 * @returns
	 */
	canUseKey(key: number, overwirte?: boolean): Promise<boolean>;
	/**
	 * 生成一个可用的新key
	 * @returns
	 */
	makeNewKey(copyKey?: number): Promise<number>;
	/**
	 * 创建一个对象
	 * @param options 创建的参数
	 * @returns
	 */
	create(options?: CreateOptions<N>): Promise<EditorObject<N> | undefined>;
	/**
	 * 获取对象在硬盘中的文件路径
	 * @param key 对象的key
	 * @returns 对象的路径
	 */
	getUri(key: number): vscode.Uri;
	getFieldInfo(field: string): FieldInfo;
	listFields(): string[];
	private _listActions;
	private resortList;
	private notifyChange;
	private changeTable;
	private _onDidChange;
	private initWatcher;
	onDidChange(callback: () => void): vscode.Disposable;
}
declare function getObject(uri: vscode.Uri | string): Promise<EditorObject | undefined>;
declare class EditorManager {
	rootUri: vscode.Uri;
	constructor(rootUri: vscode.Uri);
	editorTables: Map<Table$2.NameCN, EditorTable<Table$2.NameCN>>;
	loadObject<N extends Table$2.NameCN>(tableName: N, key: number): Promise<y3.table.EditorObject<N> | null>;
	/**
	 * 打开物编表
	 * @param tableName 哪种表
	 * @returns 表对象
	 */
	openTable<N extends Table$2.NameCN>(tableName: N): EditorTable<N>;
	private _allObjects?;
	private _allObjectsMap?;
	private _cacheVersion;
	private flushCache;
	getAllObjects(): Promise<y3.table.EditorObject<"\u5355\u4F4D" | "\u58F0\u97F3" | "\u6280\u80FD" | "\u88C5\u9970\u7269" | "\u53EF\u7834\u574F\u7269" | "\u7269\u54C1" | "\u9B54\u6CD5\u6548\u679C" | "\u6295\u5C04\u7269" | "\u79D1\u6280">[]>;
	getObjectsByKey(key: number): Promise<EditorObject[]>;
	flushName(): void;
}
declare function openTable<N extends Table$2.NameCN>(tableName: N): EditorTable<N>;
declare function getAllObjects(): Promise<y3.table.EditorObject<"\u5355\u4F4D" | "\u58F0\u97F3" | "\u6280\u80FD" | "\u88C5\u9970\u7269" | "\u53EF\u7834\u574F\u7269" | "\u7269\u54C1" | "\u9B54\u6CD5\u6548\u679C" | "\u6295\u5C04\u7269" | "\u79D1\u6280">[]>;
declare function getObjectsByKey(key: number): Promise<EditorObject[]>;
declare let fixedFloat: boolean;
declare function init$1(): void;
declare function ready$1(): Promise<void>;
declare function get(key: string | number | bigint): string | undefined;
declare function set(key: string | number | bigint, value: string): void;
declare function keyOf(value: string | number, preferNumber?: boolean): string | bigint;
declare function onDidChange(listener: () => void): vscode.Disposable;
export declare function download(options: string | URL | https.RequestOptions): Promise<Buffer>;
export declare let log: vscode.LogOutputChannel;
declare class File {
	private _data;
	write(data: Uint8Array): this;
	get buffer(): Buffer;
	get string(): string;
}
declare function readFile(uri: vscode.Uri | string, relativePath?: string): Promise<File | undefined>;
declare function writeFile(uri: vscode.Uri | string, relativePath: string | undefined, data: string): Promise<boolean>;
declare function writeFile(uri: vscode.Uri | string, data: string): Promise<boolean>;
interface DeleteOptions {
	/**
	 * 递归删除文件夹
	 */
	recursive?: boolean;
	/**
	 * 尝试移动到回收站
	 */
	useTrash?: boolean;
}
declare function removeFile(uri: vscode.Uri | string, options?: DeleteOptions): Promise<boolean>;
declare function removeFile(uri: vscode.Uri | string, relativePath?: string, options?: DeleteOptions): Promise<boolean>;
declare function dir(uri: vscode.Uri | string, relativePath?: string): Promise<[
	string,
	vscode.FileType
][]>;
declare function scan(uri: vscode.Uri | string, relativePath?: string, partail?: (result: [
	string,
	vscode.FileType
][]) => void): Promise<[
	string,
	vscode.FileType
][]>;
declare function stat(uri: vscode.Uri | string, relativePath?: string): Promise<vscode.FileStat | undefined>;
declare function isFile(uri: vscode.Uri | string, relativePath?: string): Promise<boolean>;
declare function isDirectory(uri: vscode.Uri | string, relativePath?: string): Promise<boolean>;
declare function isExists(uri: vscode.Uri | string, relativePath?: string): Promise<boolean>;
interface CopyOptions {
	overwrite?: boolean;
	recursive?: boolean;
	nameMap?: string;
	pattern?: RegExp;
}
declare function copy(source: vscode.Uri | string, target: vscode.Uri | string, options?: CopyOptions): Promise<boolean>;
declare function isRelativePath(path: string): boolean;
declare function isAbsolutePath(path: string): boolean;
type Item = string | boolean | number | bigint | null | JObject | JArray;
type JArray = Item[];
type JObject = {
	[key: string]: Item;
};
interface formatOptions {
	stringify?: (value: any) => string | undefined;
	patchEdit?: (edit: jsonc.Edit) => jsonc.Edit;
	patchJson?: boolean;
}
declare class Json {
	private options?;
	private _text;
	constructor(text: string, options?: formatOptions | undefined);
	get text(): string;
	private _data?;
	get data(): JObject | undefined;
	private _tree?;
	get tree(): jsonc.Node | undefined;
	get(key: string): Item | undefined;
	private _patch?;
	set(key: string, value: any): boolean;
	private applyPatch;
}
declare function parse(text: string): any;
declare const encodeOptions: {
	readonly newline: "\n";
	readonly indent: "    ";
	readonly depth: 0;
};
declare const keywords: Set<string>;
declare function getValidName(name: string, reserved?: Set<string>): string;
declare function encode(jsObject: any, options?: Partial<typeof encodeOptions>): string;
declare function launch(): Promise<boolean>;
interface Version {
	version: number;
	display: string;
}
declare function getClient(): Promise<Version | undefined>;
declare function getServer(): Promise<Version | undefined>;
declare function needUpdate(): Promise<boolean>;
interface UpdateResult {
	client?: Version;
	server?: Version;
}
declare function onDidChange$1(callback: (result: UpdateResult) => void): void;
declare function askUpdate(): Promise<boolean>;
declare function init$2(): void;
declare class VersionCache<T> {
	private maker;
	private cache;
	constructor(maker: () => T | Promise<T>, cache: T);
	private version;
	private hasNew;
	updateVersion(): void;
	get(): Promise<T>;
}
type EditorVersion = "1.0" | "2.0" | "unknown";
declare class Map$1 {
	name: string;
	uri: vscode.Uri;
	id: bigint;
	editorTable: EditorManager;
	description: string;
	scriptUri: vscode.Uri;
	constructor(name: string, uri: vscode.Uri);
	start(): Promise<void>;
}
declare class Project {
	uri: vscode.Uri;
	constructor(uri: vscode.Uri);
	entryMapId: bigint;
	maps: Map$1[];
	entryMap?: Map$1;
	start(): Promise<void>;
	findMapByUri(uri: vscode.Uri): Map$1 | undefined;
}
declare class Env {
	private envChangeEmitter;
	onDidChange: vscode.Event<void>;
	private searchEditorUriByReg;
	private isValidEditorPath;
	private searchEditorUri;
	private getEditorVersion;
	private searchProjectByFolder;
	private searchProject;
	private getEditorExeUri;
	editorVersion: EditorVersion;
	editorUri?: vscode.Uri;
	editorExeUri?: vscode.Uri;
	mapUri?: vscode.Uri;
	scriptUri?: vscode.Uri;
	globalScriptUri?: vscode.Uri;
	y3Uri?: vscode.Uri;
	pluginUri?: vscode.Uri;
	projectUri?: vscode.Uri;
	editorTableUri?: vscode.Uri;
	excelUri?: vscode.Uri;
	ruleUri?: vscode.Uri;
	project?: Project;
	currentMap?: Map$1;
	private _editorTablePath;
	get editorTablePath(): string;
	private _timer?;
	private fireOnDidReload;
	updateEditor(askUser?: boolean): Promise<void>;
	editorReady(askUser?: boolean): Promise<void>;
	updateCurrentMap(map: Map$1): void;
	updateMap(search: boolean, askUser: boolean): Promise<void>;
	mapReady(askUser?: boolean): Promise<void>;
}
export declare const env: Env;
interface ExportInfo {
	name: string;
	async: boolean;
	line: number;
}
declare class Plugin {
	uri: vscode.Uri;
	name: string;
	private rawCode?;
	private fixedCode?;
	private script?;
	private parseError?;
	private exports;
	constructor(uri: vscode.Uri, name: string);
	setCode(code: string): void;
	reload(): Promise<void>;
	private parse;
	getExports(): Promise<Record<string, ExportInfo>>;
	running: boolean;
	run(funcName: string, sandbox: vm.Context): Promise<void>;
	private _onceDidRun;
	private fireDidRun;
	onceDidRun(callback: (data: {
		funcName: string;
		result: any;
	}) => void | Promise<void>): void;
}
declare class PluginManager extends vscode.Disposable {
	dir: vscode.Uri;
	private _ready;
	private _disposables;
	private _onDidChange;
	constructor(dir: vscode.Uri);
	private notifyChange;
	onDidChange: vscode.Event<void>;
	plugins: Record<string, Plugin>;
	private loadPlugins;
	private ready;
	private static requireCache;
	private makeSandbox;
	getName(uri: vscode.Uri): string | undefined;
	findPlugin(uri: vscode.Uri): Promise<Plugin | undefined>;
	run(uri: vscode.Uri, funcName: string): Promise<void>;
	getAll(): Promise<Plugin[]>;
	runAll(funcName: string): Promise<number>;
}
declare function runAllPlugins(funcName: string): Promise<void>;
declare function onceDidRun(callback: (data: {
	funcName: string;
	result: any;
}) => void | Promise<void>): void;
declare function getManager(): PluginManager | undefined;
declare function init$3(): Promise<void>;
export declare let helper: vscode.ExtensionContext;
/**
 * 拼接路径为 Uri
 * @returns
 */
export declare function uri(base: vscode.Uri | string, ...paths: string[]): vscode.Uri;
/**
 * 获取《Y3开发助手》插件的相对路径
 * @returns
 */
export declare function extensionPath(...paths: string[]): vscode.Uri;
export declare function setContext(ctx: vscode.ExtensionContext): void;
/**
 * 打印内容，也会打印到日志窗口中
 * @param args 要打印的内容
 */
export declare function print(...args: any[]): void;
/**
 * 在VSCode中打开文件
 * @param uri 文件路径
 */
export declare function open(uri: vscode.Uri | string, line?: number): void;
/**
 * 在Windows中打开文件
 * @param uri 文件路径
 */
export declare function openInExplorer(uri: vscode.Uri | string): void;
export declare function sleep(ms: number): Promise<void>;
export declare function assert(exp: any, msg?: string): asserts exp;

declare namespace exceljs {
	export { AboveAverageRuleType, AddWorksheetOptions, Address, Alignment, Anchor, AutoFilter, Border, BorderDiagonal, BorderStyle, Borders, Buffer$1 as Buffer, CalculationProperties, Cell, CellErrorValue, CellFormulaValue, CellHyperlinkValue, CellIsOperators, CellIsRuleType, CellMatrix, CellModel, CellRichTextValue, CellSharedFormulaValue, CellValue, CfvoTypes, Color, ColorScaleRuleType, Column, Comment, CommentEditAs, CommentMargins, CommentProtection, ConditionalFormattingBaseRule, ConditionalFormattingOptions, ConditionalFormattingRule, ContainsTextOperators, ContainsTextRuleType, Csv, CsvReadOptions, CsvWriteOptions, Cvfo, DataBarRuleType, DataValidation, DataValidationOperator, DefinedNames, DefinedNamesModel, DefinedNamesRanges, DocumentType, ErrorValue, ExpressionRuleType, FastCsvFormatterOptionsArgs, FastCsvParserOptionsArgs, Fill, FillGradientAngle, FillGradientPath, FillPattern, FillPatterns, Font, FormulaType, GradientStop, HeaderArray, HeaderFooter, HeaderTransformFunction, IAnchor, IconSetRuleType, IconSetTypes, Image, ImageHyperlinkValue, ImagePosition, ImageRange, JSZipGeneratorOptions, Location, Margins, Media, PageSetup, PaperSize, Protection, QuoteColumnMap, QuoteColumns, Range, ReadingOrder, RelationshipType, RichText, Row, RowArray, RowBreak, RowHashArray, RowMap, RowModel, RowTransformCallback, RowTransformFunction, RowValues, Rows, Style, Table, TableColumn, TableColumnProperties, TableProperties, TableStyleProperties, TimePeriodRuleType, TimePeriodTypes, Top10RuleType, ValueType, Workbook, WorkbookModel, WorkbookProperties, WorkbookView, Worksheet, WorksheetModel, WorksheetProperties, WorksheetProtection, WorksheetState, WorksheetView, WorksheetViewCommon, WorksheetViewFrozen, WorksheetViewNormal, WorksheetViewSplit, Xlsx, XlsxReadOptions, XlsxWriteOptions, config, stream };
}
declare namespace version {
	export { askUpdate, getClient, getServer, init$2 as init, needUpdate, onDidChange$1 as onDidChange };
}
declare namespace excel {
	export { CellTable, Excel, MultiCellTable, MultiTable, Sheet, Table$1 as Table, init, loadFile, loadFileWithAllSheets, rule, setBaseDir };
}
declare namespace table {
	export { EditorData, EditorManager, EditorObject, EditorTable, FieldInfo, fixedFloat, getAllObjects, getObject, getObjectsByKey, openTable, ready };
}
declare namespace language {
	export { get, init$1 as init, keyOf, onDidChange, ready$1 as ready, set };
}
declare namespace fs {
	export { copy, dir, isAbsolutePath, isDirectory, isExists, isFile, isRelativePath, readFile, removeFile, scan, stat, writeFile };
}
declare namespace json {
	export { Item, JArray, JObject, Json, formatOptions, parse };
}
declare namespace lua {
	export { encode, getValidName, keywords };
}
declare namespace tracy {
	export { launch };
}
declare namespace consts {
	export { Table$2 as Table };
}
declare namespace plugin {
	export { getManager, init$3 as init, onceDidRun, runAllPlugins };
}
declare namespace y3 {
	export { consts, excel, exceljs, fs, json, language, lua, plugin, table, tracy, version };
}

export {
	VersionCache as Cache,
	consts,
	excel,
	exceljs,
	fs,
	is,
	json,
	language,
	lua,
	plugin,
	table,
	tracy,
	version,
};

export {};
